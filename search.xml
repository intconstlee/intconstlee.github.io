<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>10.18闲话</title>
      <link href="/2023/10/17/10-18%E9%97%B2%E8%AF%9D/"/>
      <url>/2023/10/17/10-18%E9%97%B2%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="闲话">10.18 闲话</h1><p>本来没有写闲话的打算的，但是大家都在写闲话，而且我这个博客已经八百年没更新了，所以我决定瞎写点水一水，顺便展示一下S2 OieR 良好的精神风貌和健康的精神状态。</p><p>目前啥也没想好，先试试博客还能不能上传，晚上再写。</p><h2 id="今日份乐子">今日份乐子</h2><p>暂无</p><h2 id="精神园地">精神园地</h2><p>我是傻逼</p><h2 id="我推の歌">我推の歌</h2><p>“在机房不要戴着耳机听歌”</p><h2 id="口胡式题解">口胡式题解</h2><p>tnnd 还没做题</p>]]></content>
      
      
      <categories>
          
          <category> 闲话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲话 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 精神状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排列组合</title>
      <link href="/2023/07/19/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/2023/07/19/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="排列组合">排列组合</h1><h2 id="一概念">一，概念</h2><p>排列：指从给定个数的元素中取出指定个数的元素进行排序；</p><p>组合：从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。</p><p>排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。</p><h2 id="二原理">二，原理</h2><h3 id="加法原理">1. 加法原理</h3><p>设集合 <span class="math inline">\(S\)</span>被划分为两两不相交的若干部分 <spanclass="math inline">\(S_1,S_2,...,S_n\)</span>，则 <spanclass="math inline">\(S\)</span>的对象数目可以通过确定它的每一部分对象数目并如此相加得到，符号化表示为<span class="math inline">\(|S|=|S_1|+|S_2|+...+|S_n|\)</span>。</p><details class="note" close><summary>例子</summary><p><p>设学校田径运动会中，学生要从田赛或径赛中选一个项目。若选田赛，则有三种选择。若选径赛，则有两种选择。</p><p>使用加法原理，共有 <span class="math inline">\(3+2=5\)</span>种报名方案。</p></p></details><h3 id="乘法原理">2. 乘法原理</h3><p>令 <span class="math inline">\(S\)</span> 是对象的有序对 <spanclass="math inline">\((a,b)\)</span> 的集合，其中第一个对象 <spanclass="math inline">\(a\)</span> 来自大小为 <spanclass="math inline">\(p\)</span> 的一个集合，而对于对象 <spanclass="math inline">\(a\)</span> 的每一个选择，对象 <spanclass="math inline">\(b\)</span> 有 <spanclass="math inline">\(q\)</span> 种选择，于是集合 <spanclass="math inline">\(S\)</span> 的大小为 <spanclass="math inline">\(p\times q\)</span>，符号化表示为 <spanclass="math inline">\(|S|=p\times q\)</span></p><details class="note" close><summary>例子</summary><p><p>设在面馆要点一碗面，面的粗细有三种，而配料有两种，任选一种粗细并搭配任意一种配料。</p><p>使用乘法原理，共有 <span class="math inline">\(3\times 2=6\)</span>种配搭。</p></p></details><p>事实上，乘法原理是加法原理的一个推论，根据对象 <spanclass="math inline">\(a\)</span> 的不同选择 <spanclass="math inline">\(a_1,a_2,...,a_p\)</span> 将 <spanclass="math inline">\(S\)</span> 划分为不相交的集合 <spanclass="math inline">\(S_1,S_2,...,S_p\)</span>，由于 <spanclass="math inline">\(b\)</span> 的选择不受 <spanclass="math inline">\(a\)</span> 的选择的影响，故每个 <spanclass="math inline">\(S_i\)</span> 的大小都是 <spanclass="math inline">\(q\)</span>，于是根据加法原理，我们可以得到 <spanclass="math inline">\(|S|=\)</span> <spanclass="math inline">\(|S_1|+|S_2|+...+|S_n|=\)</span> <spanclass="math inline">\(q+q+...+q=p\times q\)</span>。</p><h2 id="三计算">三，计算</h2><h3 id="排列数">1. 排列数</h3><p>从 <span class="math inline">\(n\)</span> 个不同的元素中，任取 <spanclass="math inline">\(m\)</span> 个元素按照一定的顺序排成一列，叫做从<span class="math inline">\(n\)</span> 个不同元素中取出 <spanclass="math inline">\(m\)</span>个元素的一个排列，所有此类排列的总数叫做从 <spanclass="math inline">\(n\)</span> 个不同元素中取出 <spanclass="math inline">\(m\)</span> 个元素的排列数，用符号 <spanclass="math inline">\(A_n^m\)</span> 表示。</p><p>排列数的计算公式如下：</p><p><span class="math inline">\(A_n^m=\)</span> <spanclass="math inline">\(n(n-1)(n-2)...(n-m+1)=\)</span> <spanclass="math inline">\(\frac{n!}{(n-m)!}\)</span></p><p>特别地，当 <span class="math inline">\(m\)</span> 等于 <spanclass="math inline">\(n\)</span>时，这类排列被称为全排列，全排列的排列数 <spanclass="math inline">\(A_n^n=n!\)</span>。</p><h3 id="组合数">2. 组合数</h3><p>从 <span class="math inline">\(n\)</span> 个不同的元素中，任取 <spanclass="math inline">\(m\)</span> 个元素组成一个集合，叫做从 <spanclass="math inline">\(n\)</span> 个不同元素中取出 <spanclass="math inline">\(m\)</span>个元素的一个组合，所有此类组合的总数叫做从 <spanclass="math inline">\(n\)</span> 个不同元素中取出 <spanclass="math inline">\(m\)</span> 个元素的组合数，用 <spanclass="math inline">\(\binom{n}{m}\)</span> 表示，读作“<spanclass="math inline">\(n\)</span> 选 <spanclass="math inline">\(m\)</span>”。</p><p>组合数的计算公式如下：</p><p><span class="math inline">\(\binom{n}{m}=\)</span> <spanclass="math inline">\(\frac{A_n^m}{m!}=\)</span> <spanclass="math inline">\(\frac{n!}{m!(n-m)!}\)</span></p><p>组合数也可以表示为 <span class="math inline">\(C_n^m\)</span>，但<span class="math inline">\(\binom{n}{m}\)</span> 被较为普遍地采用。</p><h2 id="四性质">四，性质</h2><h3 id="简单组合数性质">简单组合数性质</h3><ol type="1"><li><p><spanclass="math inline">\(\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\)</span></p></li><li><p><spanclass="math inline">\(\binom{n}{m}=\binom{n}{n-m}\)</span></p></li><li><p><spanclass="math inline">\(\binom{n+r+1}{r}=\sum_{i=0}^r\binom{n+i}{i}\)</span></p></li><li><p><spanclass="math inline">\(\binom{n}{m}\binom{m}{r}=\binom{n}{r}\binom{n-r}{m-r}\)</span></p></li><li><p><spanclass="math inline">\(m\binom{n}{m}=n\binom{n-1}{m-1}\)</span></p></li><li><p><spanclass="math inline">\(\binom{n+m}{r}=\sum_{i=0}^r\binom{n}{i}\binom{m}{r-i}\)</span></p></li><li><p><span class="math inline">\(\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\)</span></p></li></ol><h2 id="五技巧">五，技巧</h2><h3 id="插板法">插板法</h3><p>插板法是用于求一类给相同元素分组方案数的技巧，也可用于求一类先行不定方程的解的组数。以下是插板法的几个经典应用场景</p><h4 id="正整数和的数目">正整数和的数目</h4><p>现有 <span class="math inline">\(n\)</span>个完全相同的元素，要求将其分为 <span class="math inline">\(k\)</span>组，保证每组至少有一个元素，一共有多少种分法。</p><p>考虑拿 <span class="math inline">\(k-1\)</span> 块板子插入到 <spanclass="math inline">\(n\)</span> 个元素两两形成的 <spanclass="math inline">\(n-1\)</span> 个空隙里，可以将 <spanclass="math inline">\(n\)</span> 个元素分为 <spanclass="math inline">\(k\)</span> 组。</p><p>因为元素是完全相同的，所以答案是 <spanclass="math inline">\(\binom{n-1}{k-1}\)</span>。</p><p>本质是求 <span class="math inline">\(x_1+x_2+...+x_k=n\)</span>的方案数。</p><h4 id="非负整数和的数目">非负整数和的数目</h4><p>此时若直接插板，可能会出现多块板子插到一个空里的情况，这时我们可以创造<span class="math inline">\(k\)</span>个虚拟元素依次填入每一组，转化为上问的问题，于是答案为 <spanclass="math inline">\(\binom{n+k-1}{k-1}\)</span>，也就是 <spanclass="math inline">\(\binom{n+k-1}{n}\)</span>。</p><h4 id="不同下界整数和的数目">不同下界整数和的数目</h4><p>本质是求 <span class="math inline">\(x_1+x_2+...+x_k=n\)</span>的方案数，并要求 <span class="math inline">\(x_i\geq a_i\)</span>。</p><p>类比无限制情况，创造 <span class="math inline">\(\sum a_i\)</span>个虚拟元素保证第 <span class="math inline">\(i\)</span> 组分到 <spanclass="math inline">\(a_i\)</span> 个，之后插板即可。</p><p>答案为 <span class="math inline">\(\binom{n-\sum a_i+k-1}{n-\suma_i}\)</span></p><h2 id="六斯特林数">六，斯特林数</h2><h3 id="第一类斯特林数">1. 第一类斯特林数</h3><p>又称斯特林轮换数，表示将 <span class="math inline">\(n\)</span>个元素划分为 <span class="math inline">\(k\)</span>个圆排列的方案数。</p><p>排成 <span class="math inline">\(k\)</span> 个圆排列可以理解成求<span class="math inline">\(1~n\)</span> 排列的个数中满足 <spanclass="math inline">\(i\)</span> 向 <spanclass="math inline">\(p_i\)</span> 连一条边后，形成 <spanclass="math inline">\(k\)</span> 个环的图的个数。</p><p>对这样的图计数可以推出 <span class="math inline">\(n\brack m\)</span>的递推式，考虑加入点 <spanclass="math inline">\(n\)</span>，第一种情况是 <spanclass="math inline">\(n\)</span> 形成了一个新的环，方案数 <spanclass="math inline">\(n-1\brackm-1\)</span>；另一种情况是插入已有的环中，由于每个点有唯一后继，所以可以插入任一点及其后缀之间，方案数为<span class="math inline">\((n-1){n-1\brack m}\)</span>。</p><p>综上，我们可以得到 <span class="math inline">\({n\brack m}={n-1\brackm-1}+(n-1){n-1\brack m}\)</span>。</p><h3 id="第二类斯特林数">2. 第二类斯特林数</h3><p>又称斯特林子集数，表示将 <span class="math inline">\(n\)</span>个元素划分为 <span class="math inline">\(k\)</span> 个集合的方案数。</p><p>依旧考虑递推 <span class="math inline">\(n\bracem\)</span>，考虑加入最后一个元素的方案数。第一种情况是单独加入一个新集合，对应方案数为<span class="math inline">\(n-1\bracem-1\)</span>；否则选择一个新的集合加入，对应方案数为 <spanclass="math inline">\(m{n-1\brace m}\)</span>。</p><p>综上，我们可以得到 <span class="math inline">\({n\brace m}={n-1\bracem-1}+m{n-1\brace m}\)</span>。</p><p>在实际应用中，第二类斯特林数更为常见。</p><h2 id="七卡特兰数">七，卡特兰数</h2><h3 id="引入">引入</h3><p>考虑如下问题：</p><ol type="1"><li><p><span class="math inline">\(n\)</span> 个数 <spanclass="math inline">\(1,2,...,n\)</span>依次进栈，问有多少种不同的出栈序列。</p></li><li><p>求长为 <span class="math inline">\(2n\)</span>的合法括号序列的数量。</p></li><li><p>求 <span class="math inline">\(2n+1\)</span>个点，每个非叶子节点都恰有两个儿子的有根无号区分左右儿子二叉树的数量。</p></li><li><p>给定 <span class="math inline">\((n+1)\times (n+1)\)</span>的网格图，问有多少种从 <span class="math inline">\((1,1)\)</span> 出发到<span class="math inline">\((n+1,n+1)\)</span>的不越过对角线的路径数量。</p></li></ol><p>这四个问题其实是等价的。</p><p>对于 2，左括号看作入栈，右括号看作出栈，转化为问题 1；对于3，考虑树的 dfs 序，左儿子看作左括号，右儿子看作右括号，则 dfs 序与长为<span class="math inline">\(2n\)</span> 的合法括号序列对应；对于4，向右走看作入栈，向上走看作出栈，等价于 1。</p><p>这些问题的答案被称为卡特兰数，记作 <spanclass="math inline">\(C_n\)</span>。</p><h3 id="推导">推导</h3><p>我们可以由第四个问题推出卡特兰数的表达式。首先，如果没有不能越过对角线这一性质，方案数显然是<spanclass="math inline">\(\binom{2n}{n}\)</span>，在越过对角线的方案中路径一定解除了次对角线<spanclass="math inline">\(y=x+1\)</span>，将路径第一次与次对角线接触位置之后的部分关于这条次对角线对称，路径终点变成了<spanclass="math inline">\((n-1,n+2)\)</span>，发现这样操作后不合法方案与<span class="math inline">\((1,1)\)</span> 到 <spanclass="math inline">\((n-1,n+2)\)</span> 的路径一一对应，所以最终 <spanclass="math inline">\(C_n=\)</span> <spanclass="math inline">\(\binom{2n}{n}-\binom{2n}{n-1}=\)</span> <spanclass="math inline">\(\frac{\binom{2n}{n}}{n+1}\)</span>。</p><h3 id="递推式">递推式</h3><p><span class="math inline">\(C_n\)</span> 满足递推式 <spanclass="math inline">\(C_n=\sum_{i\geq 0}C_iC_{n-1-i}\)</span>。</p><details class="note" open><summary>证明</summary><p><p>考虑括号序列，左括号视为 +1，右括号视为-1，合法括号序列等价于前缀和恒费负且序列和为 0 的序列。</p><p>枚举第一个前缀和为 <span class="math inline">\(0\)</span>的位置，并以此将括号序列分为两部分，前一部分是长为 <spanclass="math inline">\(2(i-1)\)</span> 的合法括号序列，后一部分是长为<span class="math inline">\(2*(n-i)\)</span>的合法括号序列，于是可以得到 <span class="math inline">\(C_n\)</span>满足递推式 <span class="math inline">\(C_n=\sum_{i\geq0}C_iC_{n-1-i}\)</span>。</p></p></details><h2 id="八容斥">八，容斥</h2><h3 id="容斥原理">1. 容斥原理</h3><p>若 <span class="math inline">\(A_1,A_2,...,A_n\)</span> 为有限集，则<span class="math inline">\(|\bigcup_{i=1}^n A_i|=\)</span> <spanclass="math inline">\(\sum_{1\leq i\leq n}A_i-\)</span> <spanclass="math inline">\(\sum_{1\leq i\leq j\leq n}|A_i\capA_j|+...+\)</span> <span class="math inline">\((-1)^{n-1}|A_1\cap...\cap A_n|\)</span>。</p><h3 id="子集容斥">2. 子集容斥</h3><p><span class="math inline">\(g(S)=\sum_{T\subsetS}f(T)\)</span>，<span class="math inline">\(f(S)=\sum_{T\subsetS}(-1)^{|S|-|T|}g(T)\)</span>。</p><p>证明：</p><p><span class="math inline">\(\sum_{T\subsetS}(-1)^{|S|-|T|}g(T)\)</span></p><p><span class="math inline">\(=\sum_{T\subsetS}(-1)^{|S|-|T|}\sum_{R\subset T}f(R)\)</span></p><p><span class="math inline">\(=\sum_{R\subset S}f(R)\sum_{R\subsetT\subset S}(-1)^{|S|-|T|}\)</span></p><p>当 <span class="math inline">\(R=S\)</span> 时，<spanclass="math inline">\(\sum_{R\subset T\subsetS}(-1)^{|S|-|T|}=1\)</span> 否则 <span class="math inline">\(\foralla\in S-R\)</span>，<span class="math inline">\(f:T\leftrightarrowT\oplus {a}\)</span> 为双射，故 <spanclass="math inline">\(\sum_{R\subset T\subsetS}(-1)^{|S|-|T|}=0\)</span></p><p>于是 <span class="math inline">\(f(S)=\sum_{T\subsetS}(-1)^{|S|-|T|}g(T)\)</span>。</p><h2 id="九二项式">九，二项式</h2><h3 id="二项式定理">1. 二项式定理</h3><p><span class="math inline">\(n\inℕ,(x+y)^n=\sum_{k=0}^n\binom{n}{k}x^ky^{n-k}\)</span></p><p>此外还有广义二项式定义：<spanclass="math inline">\(|x|&lt;1,\alpha\in ℝ\)</span>，则 <spanclass="math inline">\((x+1)^{\alpha}=\sum_{k=0}^{\infty}\binom{\alpha}{k}x^k\)</span>，此处的<spanclass="math inline">\(\binom{\alpha}{k}:=\frac{a^{\underline{k}}}{k!}\)</span>。<spanclass="math inline">\(|x|\geq 1\)</span> 时，右侧幂级数不一定收敛。</p><h3 id="二项式反演">2. 二项式反演</h3><p><span class="math inline">\(g_i=\)</span> <spanclass="math inline">\(\sum_{k\geq i}\binom{k}{i}f_k\)</span>，<spanclass="math inline">\(f_i=\)</span> <spanclass="math inline">\(\sum{k\geqi}\binom{k}{i}(-1)^{k-i}g_k\)</span></p><p>证明：</p><p><span class="math inline">\(\sum_{k\geqi}\binom{k}{i}(-1)^{k-i}g_k\)</span></p><p><span class="math inline">\(=\sum_{k\geqi}\binom{k}{i}(-1)^{k-i}\sum_{j\geq k}\binom{j}{k}f_j\)</span></p><p><span class="math inline">\(=\sum_{j\geq i}f_j\sum_{i\leq k\leqj}\binom{k}{i}\binom{j}{k}(-1)^{k-i}\)</span></p><p><span class="math inline">\(=\sum_{j\geqi}f_j\frac{j!}{i!}\sum_{i\leq k\leqj}\frac{1}{(j-k)!(k-i)!}(-1)^{k-i}\)</span></p><p><span class="math inline">\(=\sum_{k\geq i}\sum_{j\geqk}f_j\frac{j!(-1)^{k-i}}{i!(j-k)!(k-i)!}\)</span></p><p><span class="math inline">\(=\sum_{k\geq i}\sum_{j\geqk}f_j\binom{j}{k}\binom{k}{i}(-1)^{k-i}\)</span><br /></p><p><span class="math inline">\(=\sum_{k\geq i}\sum_{j\geqk}f_j\binom{j}{i}\binom{j-i}{k-i}1^{j-k}(-1)^{k-i}\)</span></p><p><span class="math inline">\(=\sum_{j\geqi}f_j\binom{j}{i}(1-1)^{j-i}\)</span></p><p><span class="math inline">\(=\sum_{j\geqi}f_j\binom{j}{i}0^{j-i}\)</span></p><p>仅当 <span class="math inline">\(j=i\)</span> 时，<spanclass="math inline">\(f_j\binom{j}{i}0^{j-i}\)</span> 有值，值为 <spanclass="math inline">\(f_i\)</span>，故 <spanclass="math inline">\(f_i=\)</span> <spanclass="math inline">\(\sum{k\geqi}\binom{k}{i}(-1)^{k-i}g_k\)</span>。</p><p>类似地：</p><p><span class="math inline">\(g_i=\)</span> <spanclass="math inline">\(\sum_{k\leq i}\binom{i}{k}f_k\)</span>，<spanclass="math inline">\(f_i=\)</span> <spanclass="math inline">\(\sum{k\leqi}\binom{i}{k}(-1)^{i-k}g_k\)</span></p><h3 id="二项式反演应用">3. 二项式反演应用</h3><p>共有 <span class="math inline">\(n\)</span> 个位置，需要令恰好 <spanclass="math inline">\(k\)</span> 个位置满足某个限制，我们可以钦定 <spanclass="math inline">\(k\)</span>个位置满足该性质，未钦定部分算出所有可能方案，利用二项式反演算出恰好<span class="math inline">\(k\)</span> 个的方案数。</p><details class="note" open><summary>例子：求长为 n 的错排个数</summary><p><p>钦定 <span class="math inline">\(k\)</span> 个位置不是错排，<spanclass="math inline">\(f_k\)</span> 表示恰好 <spanclass="math inline">\(k\)</span> 个位置不是错排的数量，<spanclass="math inline">\(g_k\)</span> 表示 <spanclass="math inline">\(k\)</span>个位置是错排，其余部分任意的排列数量，于是我们要求的是 <spanclass="math inline">\(f_0\)</span>，根据二项式反演，<spanclass="math inline">\(f_0=\)</span> <spanclass="math inline">\(\sum_{k\geq 0}\binom{k}{0}(-1)^{k-0}g_k=\)</span><span class="math inline">\(\sum_{k\geq 0}(-1)^kg_k\)</span>。</p><p>易得 <spanclass="math inline">\(g_k=\binom{n}{k}(n-k)!\)</span>，即从 <spanclass="math inline">\(n\)</span> 个位置中选 <spanclass="math inline">\(k\)</span>个使强制满足条件，余下部分求全排列数量。</p><p>故 <span class="math inline">\(f_0=\)</span> <spanclass="math inline">\(\sum_{k\geq0}(-1)^k\binom{n}{k}(n-k)!\)</span>。</p></p></details>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>李超线段树</title>
      <link href="/2023/06/26/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2023/06/26/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="李超线段树">李超线段树</h1><h2 id="一问题背景">一，问题背景</h2><p>要求在平面直角坐标系上维护 <span class="math inline">\(n\)</span>个操作，操作有如下两种（强制在线）：</p><ol type="1"><li><p>在平面上加入一条线段，给出两端点横纵坐标 <spanclass="math inline">\((x_0,y_0)\)</span>，<spanclass="math inline">\((x_1,y_1)\)</span>。</p></li><li><p>给定一个横坐标的值 <span class="math inline">\(k\)</span>，求当<span class="math inline">\(x=k\)</span> 时平面中使得 <spanclass="math inline">\(y\)</span>最大的直线的编号（若有多条取编号最小的），若不存在，输出 <spanclass="math inline">\(0\)</span>。</p></li></ol><p>数据范围：<span class="math inline">\(1\leq n\leq10^5\)</span>，<span class="math inline">\(1\leq k\)</span>, <spanclass="math inline">\(x_0\)</span>, <span class="math inline">\(x_1\leq4\times 10^4\)</span>，<span class="math inline">\(1\leq y_0\)</span>,<span class="math inline">\(y_1\leq 10^9\)</span>。</p><p>分析：在这样一个问题中，操作一相当于对一段区间进行修改，操作二相当于对某一点进行查询，容易想到线段树。由于我们只关心最优解，所以在插入线段时，如果它比原来的线段更优，我们便不再需要记录原来的线段了，所以在线段树中记录每个区间中有可能成为最优解的线段即可。</p><h2 id="二实现过程">二，实现过程</h2><p>首先对于区间修改，按线段树问题的常用方法，可以给每个结点打一个懒标记，每个结点的懒标记都是一条线段，包含斜率和截距。</p><p>现在考虑插入线段 <span class="math inline">\(f\)</span> 的过程：</p><ol type="1"><li><p>如果当前区间没有被任何一条线段覆盖，直接修改。</p></li><li><p>比较端点，如果新线段被原有线段完全覆盖，直接返回。</p></li><li><p>比较端点，如果新线段可完全覆盖原有线段，直接修改。</p></li><li><p>通过区间中点大小和端点值大小判断新旧线段覆盖的长度关系，覆盖长度长的记录在该结点，短的由于只覆盖了左区间或右区间的一部分，可以递归入左或右子树。</p></li></ol><p>现在考虑单点查询的过程：</p><p>对于给定的横坐标，将递归子区间过程中所经过的每一条被记录的线段都拿出来比较。</p><details class="note" open><summary>为什么要全部比较</summary><p>在插入线段的过程中，我们发现标记之间很难合并，所以采用的是标记永久化策略，所以在单点查询递归子区间的过程中要取出所有经过区间的标记。</p></details><h3 id="参考代码">参考代码</h3><p>变量声明： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr pair<span class="string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> <span class="type">const</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> mod1=<span class="number">39989</span>,mod2=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,t,op,X0,X1,Y0,Y1,lst,tr[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span> &#123;<span class="type">double</span> k,b;&#125; l[<span class="number">100005</span>];</span><br></pre></td></tr></table></figure></p><p>下传标记： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x-y&gt;eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y-x&gt;eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;y=tr[rt],mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(<span class="built_in">Y</span>(x,mid),<span class="built_in">Y</span>(y,mid))==<span class="number">1</span>) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> cl=<span class="built_in">cmp</span>(<span class="built_in">Y</span>(x,l),<span class="built_in">Y</span>(y,l)),cr=<span class="built_in">cmp</span>(<span class="built_in">Y</span>(x,r),<span class="built_in">Y</span>(y,r));</span><br><span class="line">    <span class="keyword">if</span>(cl==<span class="number">1</span>||(!cl&amp;&amp;x&lt;y)) <span class="built_in">update</span>(ls,l,mid,x);</span><br><span class="line">    <span class="keyword">if</span>(cr==<span class="number">1</span>||(!cr&amp;&amp;x&lt;y)) <span class="built_in">update</span>(rs,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拆分线段： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;R||r&lt;L) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;<span class="built_in">update</span>(rt,l,r,x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">change</span>(ls,l,mid,L,R,x),<span class="built_in">change</span>(rs,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单点查询： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> pr <span class="title">mx</span><span class="params">(pr x,pr y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.first,y.first)==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.first,y.first)==<span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">return</span> x.second&lt;y.second?x:y;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function">pr <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;r||x&lt;l) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> ret=<span class="built_in">Y</span>(tr[rt],x);</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> &#123;ret,tr[rt]&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mx</span>(&#123;ret,tr[rt]&#125;,<span class="built_in">mx</span>(<span class="built_in">query</span>(ls,l,mid,x),<span class="built_in">query</span>(rs,mid+<span class="number">1</span>,r,x)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rt&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr pair<span class="string">&lt;double,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> <span class="type">const</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> mod1=<span class="number">39989</span>,mod2=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,t,op,X0,X1,Y0,Y1,lst,tr[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span> &#123;<span class="type">double</span> k,b;&#125; l[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x-y&gt;eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y-x&gt;eps) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pr <span class="title">mx</span><span class="params">(pr x,pr y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.first,y.first)==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(x.first,y.first)==<span class="number">-1</span>) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">return</span> x.second&lt;y.second?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l[i].k*x+l[i].b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">newline</span><span class="params">(<span class="type">int</span> X0,<span class="type">int</span> Y0,<span class="type">int</span> X1,<span class="type">int</span> Y1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++t;</span><br><span class="line">    <span class="keyword">if</span>(X0==X1) l[t].k=<span class="number">0</span>,l[t].b=<span class="built_in">max</span>(Y0,Y1);</span><br><span class="line">    <span class="keyword">else</span> l[t].k=(Y1-Y0)*<span class="number">1.0</span>/(X1-X0),l[t].b=Y0-l[t].k*X0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;y=tr[rt],mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(<span class="built_in">Y</span>(x,mid),<span class="built_in">Y</span>(y,mid))==<span class="number">1</span>) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="type">int</span> cl=<span class="built_in">cmp</span>(<span class="built_in">Y</span>(x,l),<span class="built_in">Y</span>(y,l)),cr=<span class="built_in">cmp</span>(<span class="built_in">Y</span>(x,r),<span class="built_in">Y</span>(y,r));</span><br><span class="line">    <span class="keyword">if</span>(cl==<span class="number">1</span>||(!cl&amp;&amp;x&lt;y)) <span class="built_in">update</span>(ls,l,mid,x);</span><br><span class="line">    <span class="keyword">if</span>(cr==<span class="number">1</span>||(!cr&amp;&amp;x&lt;y)) <span class="built_in">update</span>(rs,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;R||r&lt;L) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) &#123;<span class="built_in">update</span>(rt,l,r,x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">change</span>(ls,l,mid,L,R,x),<span class="built_in">change</span>(rs,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pr <span class="title">query</span><span class="params">(<span class="type">int</span> rt,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;r||x&lt;l) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> ret=<span class="built_in">Y</span>(tr[rt],x);</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> &#123;ret,tr[rt]&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mx</span>(&#123;ret,tr[rt]&#125;,<span class="built_in">mx</span>(<span class="built_in">query</span>(ls,l,mid,x),<span class="built_in">query</span>(rs,mid+<span class="number">1</span>,r,x)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        op=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            X0=<span class="built_in">rd</span>(),Y0=<span class="built_in">rd</span>(),X1=<span class="built_in">rd</span>(),Y1=<span class="built_in">rd</span>();</span><br><span class="line">            X0=(X0+lst<span class="number">-1</span>+mod1)%mod1+<span class="number">1</span>,X1=(X1+lst<span class="number">-1</span>+mod1)%mod1+<span class="number">1</span>;</span><br><span class="line">            Y0=(Y0+lst<span class="number">-1</span>+mod2)%mod2+<span class="number">1</span>,Y1=(Y1+lst<span class="number">-1</span>+mod2)%mod2+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(X0&gt;X1) <span class="built_in">swap</span>(X0,X1),<span class="built_in">swap</span>(Y0,Y1);</span><br><span class="line">            <span class="built_in">newline</span>(X0,Y0,X1,Y1),<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,mod1,X0,X1,t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            X0=<span class="built_in">rd</span>(),X0=(X0+lst<span class="number">-1</span>+mod1)%mod1+<span class="number">1</span>;</span><br><span class="line">            lst=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,mod1,X0).second;</span><br><span class="line">            <span class="built_in">wt</span>(lst),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 李超线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费用流</title>
      <link href="/2023/06/23/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
      <url>/2023/06/23/%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="费用流">费用流</h1><h2 id="一相关概念">一，相关概念</h2><p>给定一网络 <spanclass="math inline">\(G=(V,E)\)</span>，除了有容量限制 <spanclass="math inline">\(c(u,v)\)</span> 外，还给出了单位流量费用 <spanclass="math inline">\(w(u,v)\)</span>，要求在最大化 <spanclass="math inline">\(\sum_{(s,v)\in E}f(s,v)\)</span>即网络总流量的情况下最小化 <span class="math inline">\(\sum_{(u,v)\inE}f(u,v)\times\)</span> <spanclass="math inline">\(w(u,v)\)</span>。这种问题被称为最小费用最大流。</p><p>费用满足斜对称性，即 <spanclass="math inline">\(w(u,v)=-w(v,u)\)</span>，这一性质的实际意义使在有流量的情况向反向流相当于退费。</p><h2 id="二求法">二，求法</h2><h3 id="ssp-算法">1. SSP 算法</h3><p>SSP算法是一个贪心算法，其核心思路是每次寻找单位费用最小的增广路进行增广直到图中不存在增广路为止。</p><p>如果图中存在单位费用为负的负圈，SSP算法无法正确求出网络的最小费用最大流，此时需要先使用消圈算法消去图上负圈。</p><h4 id="正确性证明">正确性证明</h4><p>设流量为 <span class="math inline">\(i\)</span> 的时候最小费用为<span class="math inline">\(f_i\)</span>。假设最初网络上无负圈，这时<span class="math inline">\(f_0=0\)</span>。</p><p>假设 SSP 算法求出的 <span class="math inline">\(f_i\)</span>是最小费用，在 <span class="math inline">\(f_i\)</span>的基础上找到一条最短增广路，求出 <spanclass="math inline">\(f_{i+1}\)</span>，此时 <spanclass="math inline">\(f_{i+1}-f_i\)</span> 是这一增广路的长度。</p><p>假设存在更小的费用 <spanclass="math inline">\(f_{i+1}&#39;\)</span>，由于 <spanclass="math inline">\(f_{i+1}-f_i\)</span> 已经是最短增广路了，所以<span class="math inline">\(f_{i+1}&#39;-f_i\)</span>一定对应一个经过至少一个负环的增广路。此时 <spanclass="math inline">\(f_i\)</span>就不是最小费用了（可以给负圈添加流量使得 <spanclass="math inline">\(f_i\)</span>流量更小），与条件矛盾，则不存在更小费用 <spanclass="math inline">\(f_{i+1}&#39;\)</span>。</p><p>综上，SSP 算法可以求出无负圈网络的最小费用最大流。</p><h4 id="实现">实现</h4><p>只需要将 EK 算法或 Dinic算法中找增广路的过程替换为用最短路算法寻找单位费用最小的增广路即可。</p><p>基于 EK 算法的实现（抬走，下一位）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;<span class="type">int</span> to,nxt,f,c&#125; e[<span class="number">2</span>*M];</span><br><span class="line"><span class="type">int</span> h[N],cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> f,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt]=&#123;y,head[x],f,c&#125;,head[x]=cnt;</span><br><span class="line">    e[++cnt]=&#123;x,head[y],<span class="number">0</span>,-c&#125;,head[y]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[N],pre[N],incf[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s),dis[s]=<span class="number">0</span>,incf[s]=inf;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(),vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&lt;=dis[u]+e[i].c||!e[i].f) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v]=dis[u]+c,incf[v]=<span class="built_in">min</span>(e[i].f,incf[u]),pre[v]=i;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mxf,mnc;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mxf+=incf[t];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=e[pre[u]^<span class="number">1</span>].to)</span><br><span class="line">    &#123;</span><br><span class="line">        e[pre[u]].f-=incf[t],e[pre[u]^<span class="number">1</span>].f+=incf[t];</span><br><span class="line">        mnc+=incf[t]*e[pre[u]].c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">spfa</span>()) <span class="built_in">update</span>()</span><br></pre></td></tr></table></figure></p><p>基于 Dinic 算法的实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N=<span class="number">5005</span>,M=<span class="number">100005</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v,w,c,mxf,mnc,cnt,head[N],dis[N],vis[N],cur[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to,nxt,f,c;&#125; e[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> f,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt]=&#123;y,head[x],f,c&#125;,head[x]=cnt;</span><br><span class="line">    e[++cnt]=&#123;x,head[y],<span class="number">0</span>,-c&#125;,head[y]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,inf,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memcpy</span>(cur,head,<span class="built_in">sizeof</span>(cur));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s),dis[s]=<span class="number">0</span>,vis[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(),vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&lt;=dis[u]+e[i].c||!e[i].f) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v]=dis[u]+e[i].c;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> F;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i&amp;&amp;lst&lt;F;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        cur[u]=i;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]||dis[v]!=dis[u]+e[i].c||!e[i].f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(F-lst,e[i].f));</span><br><span class="line">        <span class="keyword">if</span>(k) e[i].f-=k,e[i^<span class="number">1</span>].f+=k,mnc+=k*e[i].c,lst+=k;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">        <span class="keyword">while</span>(k) ret+=k,k=<span class="built_in">dfs</span>(s,inf);;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),s=<span class="built_in">rd</span>(),t=<span class="built_in">rd</span>(),cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(u,v,w,c);</span><br><span class="line">    mxf=<span class="built_in">mcmf</span>();</span><br><span class="line">    <span class="built_in">wt</span>(mxf),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>),<span class="built_in">wt</span>(mnc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="primal-dual-原始对偶算法">2. Primal-Dual 原始对偶算法</h3><p>在此仅做简单讲解，不做正确性证明。</p><h4 id="过程">过程</h4><p>用 SPFA 求最短路的时间复杂度是 <spanclass="math inline">\(O(nm)\)</span> 的，不及 Dijkstra算法，但由于网络中存在费用为负的边，无法直接使用 Dijkstra。</p><p>Primal-Dual 原始对偶算法的思路与<ahref="https://oi-wiki.org/graph/shortest-path/#johnson-%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95">Johnson全源最短路</a>类似，为每个点设置一个势能，使所有边的费用均变为非负，从而可以用Dijkstra 找出网络上单位费用最小的增广路。</p><p>首先跑一次最短路，找出源点到每个点的最短距离 <spanclass="math inline">\(h_i\)</span>，之后和 Johnson 算法一样，对于一条从<span class="math inline">\(u\)</span> 到 <spanclass="math inline">\(v\)</span> 的单位为 <spanclass="math inline">\(w\)</span> 的边，将其费用重置为 <spanclass="math inline">\(w+h_u-h_v\)</span>。</p><p>与常规最短路问题不同的是，每次增广后图的形态会发生变化，这种情况下各点是能需要更新。设增广后从源点到<span class="math inline">\(i\)</span> 号点的距离为 <spanclass="math inline">\(d_i&#39;\)</span>（这里的距离是重置各边费用后的距离），只需要给<span class="math inline">\(h_i\)</span> 加上 <spanclass="math inline">\(d_i&#39;\)</span> 即可。</p><h4 id="实现-1">实现</h4><p>由于不会 Johnson 最短路，只能放上 OI-wiki了，之后会更新正确性证明和实现代码 <ahref="https://oi-wiki.org/graph/flow/min-cost/#primal-dual-%E5%8E%9F%E5%A7%8B%E5%AF%B9%E5%81%B6%E7%AE%97%E6%B3%95">OI-wiki</a>。</p>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小割</title>
      <link href="/2023/06/20/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
      <url>/2023/06/20/%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="最小割">最小割</h1><h2 id="一相关概念">一，相关概念</h2><h3 id="割">割：</h3><p>对于一个网络流图 <spanclass="math inline">\(G=(V,E)\)</span>，将所有点划分为两个集合 <spanclass="math inline">\(S\)</span> 与 <spanclass="math inline">\(T\)</span>，该划分满足：</p><ol type="1"><li><span class="math inline">\(s\in S,\)</span> <spanclass="math inline">\(t\in T\)</span></li><li><span class="math inline">\(S\cap T=\varnothing,\)</span> <spanclass="math inline">\(S\cup T=V\)</span></li></ol><p>称这种点的划分方式为割。</p><h3 id="割的容量">割的容量：</h3><p>割 <span class="math inline">\((S,T)\)</span> 的容量为所有从 <spanclass="math inline">\(S\)</span> 到 <spanclass="math inline">\(T\)</span> 的边的容量之和，即：</p><p><span class="math inline">\(c(S,T)=\)</span> <spanclass="math inline">\(\sum_{u\in S,v\in T}c(u,v)\)</span></p><p>也可以表示为<span class="math inline">\(c(s,t)\)</span>。</p><h3 id="最小割-1">最小割</h3><p>求一个割 <span class="math inline">\((S,T)\)</span> 使得 <spanclass="math inline">\(c(S,T)\)</span> 最小。</p><h2 id="二最小割求法">二，最小割求法</h2><h3 id="最大流最小割">最大流最小割</h3><p>对于一个网络流图，其最大流与最小割相等，即：</p><p><span class="math inline">\(f(s,t)_{max}=c(s,t)_{min}\)</span></p><details class="note" open><summary>证明</summary><p>根据流量守恒特性可以得到 <span class="math inline">\(\forall u\inV-\{s,t\}\)</span>，<span class="math inline">\(\sum_{v\inV}f(u,v)-\)</span> <span class="math inline">\(\sum_{v\inV}f(v,u)=\)</span> <span class="math inline">\(0\)</span>。</p><p>根据流的定义，<span class="math inline">\(|f|=\)</span> <spanclass="math inline">\(\sum_{v\in V}f(s,v)-\)</span> <spanclass="math inline">\(\sum_{v\in V}f(v,s)\)</span>。</p><p>变形，得：</p><p>$ |f| = $ <span class="math inline">\(\sum_{v \in V}f(s,v) -\)</span><span class="math inline">\(\sum_{v \in V}f(v,s) +\)</span> <spanclass="math inline">\(\sum_{u \in S-\{s\}}(\sum_{v \in V}f(u,v)-\)</span> <span class="math inline">\(\sum_{v \inV}f(v,u))\)</span></p><p>$ |f| = $ <span class="math inline">\(\sum_{v \in V}f(s,v) -\)</span><span class="math inline">\(\sum_{v \in V}f(v,s) +\)</span> <spanclass="math inline">\(\sum_{u \in S-\{s\}}\sum_{v \in V}f(u,v)-\)</span> <span class="math inline">\(\sum_{u \in S-\{s\}}\sum_{v \inV}f(v,u)\)</span></p><p>$ |f| = $ <span class="math inline">\(\sum_{v \in V}(f(s,v)+\)</span> <span class="math inline">\(\sum_{u \in S-\{s\}}f(u,v))-\)</span> <span class="math inline">\(\sum_{v \in V}(f(v,u) +\)</span><span class="math inline">\(\sum_{u \in S-\{s\}}f(v,u))\)</span></p><p>$ |f| = $ <span class="math inline">\(\sum_{v \in V}\sum_{u \inS}f(u,v) -\)</span> <span class="math inline">\(\sum_{v \in V}\sum_{u\in S}f(v,u)\)</span></p><p>$ |f| = $ <span class="math inline">\(\sum_{v\in V-S}\sum_{u \inS}f(u,v) +\)</span> <span class="math inline">\(\sum_{v\in S}\sum_{u\inS}f(u,v) -\)</span> <span class="math inline">\((\sum_{v\inV-S}\sum_{u\in S}f(v,u) +\)</span> <spanclass="math inline">\(\sum_{v\in S}\sum_{u\in S}f(v,u))\)</span></p><p>$ |f| = $ <span class="math inline">\((\sum_{v\in T}\sum_{u \inS}f(u,v) -\)</span> <span class="math inline">\(\sum_{v\in T}\sum_{u\inS}f(v,u)) +\)</span> <span class="math inline">\(( \sum_{v\inS}\sum_{u\in S}f(u,v) -\)</span> <span class="math inline">\(\sum_{v\inS}\sum_{u\in S}f(v,u))\)</span></p><p>即：<span class="math inline">\(|f|=\)</span> <spanclass="math inline">\(f(S,T)+0=\)</span> <spanclass="math inline">\(f(S,T)\)</span>。</p><p>即任意横跨切割的流量等于网络的流量，又有横跨任意切割的流量不大于切割的容量，可知，网络的流量不大于任意切割的容量，即<span class="math inline">\(f(S,T)\leq c(S,T)\)</span>，<spanclass="math inline">\(\forall c(S,T)\)</span>。</p><p>于是一个网络最大流的值就等于最小切割的容量，这就是最大流最小割定理。</p></details><p>通过最大流最小割定理，我们可以直接通过求最大流来获得最小割。</p><h3 id="最小割方案">最小割方案</h3><h4 id="最小割的可行边">最小割的可行边</h4><p>条件：</p><ol type="1"><li><p>满流；</p></li><li><p>在残余网络中不连通。</p></li></ol><p>做完最大流后，求残量网络的 SCC。设点 <spanclass="math inline">\(x\)</span> 所在的 SCC 为 <spanclass="math inline">\(\text{SCC}[x]\)</span>。对于饱和边 <spanclass="math inline">\((u,v)\)</span>，若 $[u]$ <spanclass="math inline">\(\text{SCC}[ v ]\)</span>，则边 <spanclass="math inline">\((u,v)\)</span> 可以在最小割上。</p><details class="note" open><summary>原因</summary><p><p>$[u]$ <span class="math inline">\(\text{SCC}[ v ]\)</span>，则说明<span class="math inline">\(u\)</span> 和 <spanclass="math inline">\(v\)</span>在残量网络中不连通，也就相当于跑最大流的时候 <spanclass="math inline">\((u,v)\)</span>满流被删去，又知最小割上的所有边都是满流的，则 <spanclass="math inline">\((u,v)\)</span> 可在最小割上。</p></p></details><h4 id="最小割的必须边">最小割的必须边</h4><p>条件：</p><ol type="1"><li><p>满流；</p></li><li><p>在残量网络中一端与源点联通，另一端与汇点联通。</p></li></ol><p>做完最大流后，求残量网络的 SCC。设点 <spanclass="math inline">\(x\)</span> 所在的 SCC 为 <spanclass="math inline">\(\text{SCC}[x]\)</span>。对于饱和边 <spanclass="math inline">\((u,v)\)</span>，若 <spanclass="math inline">\(\text{SCC}[u]=\)</span> <spanclass="math inline">\(\text{SCC}[s]\)</span>，<spanclass="math inline">\(\text{SCC}[v]=\)</span> <spanclass="math inline">\(\text{SCC}[t]\)</span>，则边 <spanclass="math inline">\((u,v)\)</span> 必须在最小割上。</p><details class="note" open><summary>原因</summary><p><p>最小割的必须边意味着如果未选中这条边，得到的一定不是最小割，即可以理解为增加容量后可以改变最大流的边，发现对于一条增广路，若其上容量最小的边唯一，那么增大它的容量将会增大整条增广路的流量，于是这条边必须在最小割上，而发现其性质之一是满流，性质之二便是在残量网络中一端与源点联通一端与汇点联通。</p></p></details><h4 id="最小割点集划分方案">最小割点集划分方案</h4><p>从源点 <span class="math inline">\(s\)</span> 开始DFS，每次走残量大于 <span class="math inline">\(0\)</span>的边，便能找到 <span class="math inline">\(S\)</span>内所有的点了，<span class="math inline">\(T\)</span> 中的点同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v]&amp;&amp;edge[i].flow&lt;edge[i].cap)</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最小割任意割边方案">最小割任意割边方案</h4><p>法一：</p><p>在残量网络中，DFS 出 <span class="math inline">\(s\)</span>能到达的集合 <span class="math inline">\(S\)</span>，<spanclass="math inline">\(S\)</span>向外连出的所有满流的边即是最小割方案之一。</p><p>法二：</p><p>每次选取一条满流边 <span class="math inline">\((u,v)\)</span> DFS判断在残量网络中能否从 <span class="math inline">\(v\)</span> 到达 <spanclass="math inline">\(u\)</span>，且不经过反向边 <spanclass="math inline">\((v,u)\)</span>，若能则 <spanclass="math inline">\((u,v)\)</span> 在最小割集中，输出即可。</p><p>但注意选取了 <span class="math inline">\((u,v)\)</span>后，某些满流边不再是最小割，所以考虑对 <spanclass="math inline">\((u,v)\)</span> 退流，后删去边 <spanclass="math inline">\((u,v)\)</span> 及其反向边。</p><h4 id="最小割最小字典序割边方案">最小割最小字典序割边方案</h4><p>类似于上文法二，但从编号小的满流边开始枚举。</p><h4 id="最少割边最小割方案">最少割边最小割方案</h4><p>做完一次最小割后领满流边容量为1，非满流边容量正无穷，再做一次最小割，此时最小割的流量就是选取的边数，任意最小割方案割边都最少。</p><h2 id="三习题">三，习题</h2><p>若无特殊情况，所有习题均只给出主函数建图代码，其余代码套用模板</p><h3><a href="https://www.luogu.com.cn/problem/P3931">洛谷P3931 一道难题</a></h3><p>根节点可看成源点，但发现没有汇点，建立一个超级汇点，在树中找到所有叶子节点，全部以正无穷的容量（保证在最小割中不会被选到）连向超级汇点，求最小割即可，记得开long long。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">t=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,<span class="built_in">addedge</span>(u,v,w);</span><br><span class="line"><span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(indg[i]==<span class="number">1</span>&amp;&amp;i!=s) <span class="built_in">addin</span>(i,t,<span class="number">1e18</span>);</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P1345">洛谷P1345奶牛的电信</a></h3><p>发现求的是使两点不连通的最小割点，考虑割点转割边，于是可以把每个点拆成两个点，一个入点和一个出点，容量为<spanclass="math inline">\(1\)</span>，这样就把点转为了边，其余所有边容量均为正无穷防止被选中。这一思路比较巧妙，其他题目也会用到类似这种点边转化的思想。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">s=s+n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">addin</span>(i,i+n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    <span class="built_in">addin</span>(u+n,v,<span class="number">0x3f3f3f3f</span>),<span class="built_in">addin</span>(v+n,u,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P2994">洛谷P2994 EarthquakeDamage G</a></h3><p>与上一题类似，割点转割边，注意到没有汇点，对于所有求救的奶牛，可知其与源点的路径上必有割点，对答案有贡献，于是将所有求救奶牛的出点连向超级汇点，之后建立出点和入点间的边，容量为<spanclass="math inline">\(1\)</span>，注意对于求救奶牛，其农场未被摧毁，容量应为正无穷防止被选中。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;p,s=n+<span class="number">1</span>,t=n*<span class="number">2</span>+<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v,<span class="built_in">addin</span>(u+n,v,inf),<span class="built_in">addin</span>(v+n,u,inf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)</span><br><span class="line">    cin&gt;&gt;u,vis[u]=<span class="number">1</span>,<span class="built_in">addin</span>(u+n,t,inf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    vis[i]?<span class="built_in">addin</span>(i,i+n,inf):<span class="built_in">addin</span>(i,i+n,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P2057">洛谷P2057善意的投票</a></h3><p>经典模型之分两个集合。先根据意愿将小朋友分为两派，一派连源点，一派连汇点，对于一对好朋友，连一条正反容量均为1的边即可。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;m,s=<span class="number">0</span>,t=n+<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin&gt;&gt;u,u?<span class="built_in">addin</span>(s,i,<span class="number">1</span>):<span class="built_in">addin</span>(i,t,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v,<span class="built_in">addin</span>(u,v,<span class="number">1</span>),<span class="built_in">addin</span>(v,u,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流重制版</title>
      <link href="/2023/06/19/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%87%8D%E5%88%B6%E7%89%88/"/>
      <url>/2023/06/19/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%87%8D%E5%88%B6%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="最大流">最大流</h1><p>前置知识：<ahref="https://intconstlee.github.io/posts/network-flows-remake/">网络流概览</a>，请确保已熟悉网络流相关概念以及流的性质。</p><p>两大核心算法：<ahref="https://oi-wiki.org/graph/flow/max-flow/#ford-fulkerson-%E5%A2%9E%E5%B9%BF">Ford-Fulkerson增广</a>与<ahref="https://oi-wiki.org/graph/flow/max-flow/#push-relabel-%E9%A2%84%E6%B5%81%E6%8E%A8%E8%BF%9B%E7%AE%97%E6%B3%95">Push-Relabel预流推进算法</a></p><h2 id="一概览">一，概览</h2><p>对于一个给定网络，有许多合法的流函数 <spanclass="math inline">\(f\)</span>，其中使整个网络的流量 <spanclass="math inline">\(\sum_{(s,v)\in E}f(s,v)\)</span>最大的流函数被称为网络的最大流，此时的流量被称为网络的最大流量。</p><h2 id="二ford-fulkerson-增广">二，Ford-Fulkerson 增广</h2><p>该方法运用贪心思想，通过寻找增广路来更新并求解最大流。</p><p>对于一张初始流量为 <span class="math inline">\(0\)</span> 的零流网络<spanclass="math inline">\(G\)</span>，找其最大流，核心的思想就是不断找从源点<span class="math inline">\(s\)</span> 到汇点 <spanclass="math inline">\(t\)</span>的路径，直到没有可行选择，这个过程被称为增广。</p><p>我们将 <span class="math inline">\(G_f\)</span> 上一条从源点 <spanclass="math inline">\(s\)</span> 到汇点 <spanclass="math inline">\(t\)</span>的路径称为增广路。对于一条增广路，我们给每一条边 <spanclass="math inline">\((u,v)\)</span>都加上等量的流量，以令整个网络的流量增加，这一过程被称为增广。</p><p>由此，最大流的求解可以被视为若干次增广分别得到的流的叠加。</p><p>值得注意的是，根据流的斜对称性，<spanclass="math inline">\(f(u,v)=-f(v,u)\)</span>，于是当我们给 <spanclass="math inline">\(f(u,v)\)</span> 增加一个流量时，<spanclass="math inline">\(f(v,u)\)</span>也应减少等量的流量，该操作被称为退流。</p><details class="note" open><summary>解释</summary><p><p>在最大流的实现过程中，需要经常进行访问反向边的操作，一条边和它的反向边都加等量流量，相当于这一条边未被访问过，通过访问反向边，我们可以在找到更优方案的时候进行退流操作，从而更新答案。具体内容请见下文示例。</p></p></details><center><img src="https://img1.imgtp.com/2023/06/27/MHqL47Fm.PNG" alt="最大流示意1.PNG" title="最大流示意1.PNG" /></center><center><img src="https://img1.imgtp.com/2023/06/27/I5O1Wcuq.PNG" alt="最大流示意2.PNG" title="最大流示意2.PNG" /></center><center><img src="https://img1.imgtp.com/2023/06/27/5xISwJQX.PNG" alt="最大流示意3.PNG" title="最大流示意3.PNG" /></center><p>通过这个例子，我们能看出，退流操作带来的“抵消”效果可以更新更优答案，只要存在增广路，就可以令其总流量增加，直到找不到增广路，总流量达到最大。</p><p>总结一下 Ford-Fulkerson 增广的步骤：</p><ol type="1"><li><p>初始化图中流的值；</p></li><li><p>在残量网络中找到增广路；</p></li><li><p>增加总流量，并重复步骤 2-3 直到不存在增广路为止。</p></li></ol><details class=note close><summary>Ford-Fulkerson 增广正确性证明</summary><p><p>首先引入割的概念（在最小割中还会详细讲）：定义一个网络流的割为一种点的划分方式<span class="math inline">\((S,T)\)</span>，其中 <spanclass="math inline">\(S\cap T=\varnothing\)</span>，<spanclass="math inline">\(S\cup T=V\)</span>，<spanclass="math inline">\(s\in S\)</span>，<span class="math inline">\(t\inT\)</span>。即在一张网络中使源点和汇点不连通的切割（删边）方案。</p><p>割的净流量：<span class="math inline">\(f(S,T)=\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\in T}f(u,v)-\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\in T}f(v,u)\)</span>；</p><p>割的容量：<span class="math inline">\(c(S,T)=\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\in T}c(u,v)\)</span></p><p>引入一个引理：设 <span class="math inline">\(f\)</span>为流网络中的一个流，横跨任何切割的净流量都相同，且都为网络的流量，即都为<span class="math inline">\(|f|\)</span>，即 <spanclass="math inline">\(|f|=f(S,T)\)</span>。</p><details class="note" close><summary>引理的证明</summary><p><p>可以从流的定义直观理解：网络流中 <spanclass="math inline">\(f\)</span> 的值是从 <spanclass="math inline">\(s\)</span>流出的流量之和，给出任意切割，这些流量都经过该切割，于是割的流量即整个网络的流量。下面为数学证明.</p><p>根据流量守恒特性可以得到 <span class="math inline">\(\forall u\inV-\{s,t\}\)</span>，<span class="math inline">\(\sum_{v\inV}f(u,v)-\)</span> <span class="math inline">\(\sum_{v\inV}f(v,u)=\)</span> <span class="math inline">\(0\)</span>。</p><p>根据流的定义，<span class="math inline">\(|f|=\)</span> <spanclass="math inline">\(\sum_{v\in V}f(s,v)-\)</span> <spanclass="math inline">\(\sum_{v\in V}f(v,s)\)</span>。</p><p>变形，得：</p><p>$|f| = $ <span class="math inline">\(\sum_{v \in V}f(s,v) -\)</span><span class="math inline">\(\sum_{v \in V}f(v,s) +\)</span> <spanclass="math inline">\(\sum_{u \in S-\{s\}}(\sum_{v \in V}f(u,v)-\)</span> <span class="math inline">\(\sum_{v \inV}f(v,u))\)</span></p><p>$|f| = $ <span class="math inline">\(\sum_{v \in V}f(s,v) -\)</span><span class="math inline">\(\sum_{v \in V}f(v,s) +\)</span> <spanclass="math inline">\(\sum_{u \in S-\{s\}}\sum_{v \in V}f(u,v)-\)</span> <span class="math inline">\(\sum_{u \in S-\{s\}}\sum_{v \inV}f(v,u)\)</span></p><p>$|f| = $ <span class="math inline">\(\sum_{v \in V}(f(s,v) +\)</span><span class="math inline">\(\sum_{u \in S-\{s\}}f(u,v)) -\)</span> <spanclass="math inline">\(\sum_{v \in V}(f(v,u) +\)</span> <spanclass="math inline">\(\sum_{u \in S-\{s\}}f(v,u))\)</span></p><p>$|f| = $ <span class="math inline">\(\sum_{v \in V}\sum_{u \inS}f(u,v) -\)</span> <span class="math inline">\(\sum_{v \in V}\sum_{u\in S}f(v,u)\)</span></p><p>$|f| = $ <span class="math inline">\(\sum_{v\in V-S}\sum_{u \inS}f(u,v) +\)</span> <span class="math inline">\(\sum_{v\in S}\sum_{u\inS}f(u,v) -\)</span> <span class="math inline">\((\sum_{v\inV-S}\sum_{u\in S}f(v,u) +\)</span> <spanclass="math inline">\(\sum_{v\in S}\sum_{u\in S}f(v,u))\)</span></p><p>$|f| = $ <span class="math inline">\((\sum_{v\in T}\sum_{u \inS}f(u,v) -\)</span> <span class="math inline">\(\sum_{v\in T}\sum_{u\inS}f(v,u)) +\)</span> <span class="math inline">\(( \sum_{v\inS}\sum_{u\in S}f(u,v) -\)</span> <span class="math inline">\(\sum_{v\inS}\sum_{u\in S}f(v,u))\)</span></p><p>即：<span class="math inline">\(|f|=\)</span> <spanclass="math inline">\(f(S,T)+0=\)</span> <spanclass="math inline">\(f(S,T)\)</span>，证毕。</p></p></details><p>由任意横跨切割的流量等于网络的流量，又有横跨任意切割的流量不大于切割的容量，可知，网络的流量不大于任意切割的容量，即<span class="math inline">\(f(S,T)\leq c(S,T)\)</span>，<spanclass="math inline">\(\forall c(S,T)\)</span>。</p><p>于是一个网络最大流的值就等于最小切割的容量，这就是最大流-最小割定理。</p><p>现在我们回到对增广正确性的证明。形式化地表示增广的结束条件为：残量网络<span class="math inline">\(G_f\)</span>不包含任何增广路。而我们要证明的就是在这一条件下得到的 <spanclass="math inline">\(f\)</span> 是原网络 <spanclass="math inline">\(G\)</span> 的一个最大流。</p><p>首先，若残量网络 <span class="math inline">\(G_f\)</span>不包含任何增广路，则其可被划分为两部分 <spanclass="math inline">\((S,T)\)</span>，其中 <spanclass="math inline">\(S\)</span> 定义为在 <spanclass="math inline">\(G_f\)</span> 中存在一条由 <spanclass="math inline">\(s\)</span> 到 <spanclass="math inline">\(v\)</span> 路径的 <spanclass="math inline">\(v\)</span> 的集合，<spanclass="math inline">\(T=V-S\)</span>。对于 <spanclass="math inline">\(\forall u\in S\)</span>，<spanclass="math inline">\(\forall v\in T\)</span>：</p><ol type="1"><li><spanclass="math inline">\(f(u,v)=c(u,v)\)</span>：如果该条件不成立，那么<span class="math inline">\(G_f\)</span> 中必然还存在 <spanclass="math inline">\(s\)</span> 到 <spanclass="math inline">\(t\)</span> 的通路，此时未完成增广；</li><li><span class="math inline">\(f(v,u)=0\)</span>：对于 <spanclass="math inline">\((v,u)\notin E\)</span>，该结论显然，对于 <spanclass="math inline">\((v,u)\in E\)</span>，若 <spanclass="math inline">\(f(v,u)\neq 0\)</span>，则 <spanclass="math inline">\(G_f\)</span> 中还存在一条 <spanclass="math inline">\((u,v)\)</span> 的路径，与 <spanclass="math inline">\(u\in S\)</span>，<span class="math inline">\(v\inT\)</span> 矛盾。</li></ol><p>结合割的净流量：<span class="math inline">\(f(S,T)=\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\in T}f(u,v)-\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\inT}f(v,u)\)</span>，得：</p><ol type="1"><li><span class="math inline">\(f(S,T)=\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\in T}f(u,v)-\)</span> <spanclass="math inline">\(0\)</span>；</li><li><span class="math inline">\(f(S,T)=\)</span> <spanclass="math inline">\(\sum_{u\in S}\sum_{v\in T}c(u,v)-\)</span> <spanclass="math inline">\(0=\)</span> <spanclass="math inline">\(c(S,T)\)</span>。</li></ol><p>于是 <span class="math inline">\(f(S,T)=c(S,T)\)</span>，而 <spanclass="math inline">\(|f|=f(S,T)\)</span>，则 <spanclass="math inline">\(|f|=c(S,T)\)</span>。</p><p>发现在这里 <span class="math inline">\(|f|=c(S,T)\)</span>取到了等号，说明 <span class="math inline">\(c(S,T)\)</span>是原网络的最小切割，否则若存在更小切割，<spanclass="math inline">\(|f|\)</span> 将会大于 <spanclass="math inline">\(c(S,T)\)</span>。于是 <spanclass="math inline">\(|f|\)</span> 为原网络的最大流，Ford-Fulkerson增广正确性证明完毕。</p></details><p>时间复杂度上界：<spanclass="math inline">\(O(|E||f|)\)</span>，单轮增广的时间复杂度是 <spanclass="math inline">\(O(|E|)\)</span>，而增广轮数不可能超过 <spanclass="math inline">\(|f|\)</span>。</p><p>接下来将介绍两个 Ford-Fulkerson 增广的主流实现方式：EK 算法和 Dinic算法。以及一个比较快但并不主流的实现方式：ISAP 算法。</p><h3 id="edmonds-karp-算法">Edmonds-Karp 算法</h3><p><span class="math inline">\(O(nm^2)\)</span></p><h4 id="算法流程">算法流程：</h4><ol type="1"><li><p>如果在 <span class="math inline">\(G_f\)</span> 上我们可以从<span class="math inline">\(s\)</span> 出发 BFS 到 <spanclass="math inline">\(t\)</span>，则我们找到了新的增广路。</p></li><li><p>对于增广路 <span class="math inline">\(p\)</span>，我们计算出<span class="math inline">\(p\)</span> 经过的边的剩余容量的最小值 <spanclass="math inline">\(\Delta=\min_{(u,v)\in p}c_f(u,v)\)</span>。我们给<span class="math inline">\(p\)</span> 上的每条边都增加 <spanclass="math inline">\(\Delta\)</span> 的流量，并给它们的反向边退掉 <spanclass="math inline">\(\Delta\)</span> 的流量，此时最大流增加了 <spanclass="math inline">\(\Delta\)</span>。</p></li><li><p>修改流量后我们得到了新的 <spanclass="math inline">\(G_f\)</span>，在新的 <spanclass="math inline">\(G_f\)</span>中重复上述过程直到增广路不存在。</p></li></ol><h4 id="参考代码">参考代码：</h4><h5 id="vector版本">vector版本</h5><ol type="1"><li><p>变量声明与初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m;    <span class="comment">// n：点数，m：边数</span></span><br><span class="line"><span class="type">int</span> a[maxn],p[maxn];    <span class="comment">// a：BFS到 x 的最大流，p：BFS中 x 的前驱</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> from,to,cap,flow;&#125;;    <span class="comment">// cap：容量，flow：流量</span></span><br><span class="line">vector&lt;Edge&gt; edge;    <span class="comment">// edge：所有边的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; id[maxn];    <span class="comment">// id：x 相邻所有点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) id[i].<span class="built_in">clear</span>();</span><br><span class="line">    edge.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge.<span class="built_in">push_back</span>(&#123;from,to,cap,<span class="number">0</span>&#125;);</span><br><span class="line">    edge.<span class="built_in">push_back</span>(&#123;to,from,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    m=edge.<span class="built_in">size</span>();</span><br><span class="line">    id[from].<span class="built_in">push_back</span>(m<span class="number">-2</span>);</span><br><span class="line">    id[to].<span class="built_in">push_back</span>(m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BFS求最大流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxflow</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s),a[s]=inf;    <span class="comment">//源点自己到自己流量正无穷</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id[u].<span class="built_in">size</span>();i++)    <span class="comment">//遍历临点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Edge e=edge[id[u][i]];</span><br><span class="line">                <span class="keyword">if</span>(a[e.to]||e.flow&gt;=e.cap) <span class="keyword">continue</span>;    <span class="comment">//搜过或已饱和</span></span><br><span class="line">                p[e.to]=id[u][i];    <span class="comment">//记录前驱，方便回溯</span></span><br><span class="line">                a[e.to]=<span class="built_in">min</span>(a[u],e.cap-e.flow);    <span class="comment">//向下赋流，求前缀最小值</span></span><br><span class="line">                q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[t]) <span class="keyword">break</span>;    <span class="comment">//汇点接到流，增广成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!a[t]) <span class="keyword">break</span>;    <span class="comment">//找不到增广路了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=edge[p[u]].from)</span><br><span class="line">        &#123;</span><br><span class="line">            edge[p[u]].flow+=a[t];    <span class="comment">//正向路径增加</span></span><br><span class="line">            edge[p[u]^<span class="number">1</span>].flow-=a[t];    <span class="comment">//反向路径减小</span></span><br><span class="line">        &#125;</span><br><span class="line">        flow+=a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="链式前向星版本">链式前向星版本</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v,w,maxflow;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>],p[<span class="number">1000</span>],vis[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> cnt,head[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> to,nxt,cap,flow;&#125; edge[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,head[x],z,<span class="number">0</span>&#125;;</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    edge[++cnt]=&#123;x,head[y],<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    head[y]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s),a[s]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge e=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(vis[e.to]||e.flow&gt;=e.cap) <span class="keyword">continue</span>;</span><br><span class="line">            p[e.to]=i,a[e.to]=<span class="built_in">min</span>(a[u],e.cap-e.flow);</span><br><span class="line">            q.<span class="built_in">push</span>(e.to),vis[e.to]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(e.to==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=edge[p[u]^<span class="number">1</span>].to)</span><br><span class="line">    &#123;</span><br><span class="line">        edge[p[u]].flow+=a[t];</span><br><span class="line">        edge[p[u]^<span class="number">1</span>].flow-=a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    maxflow+=a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t,cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,<span class="built_in">addin</span>(u,v,w);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s,t)) <span class="built_in">update</span>(s,t);</span><br><span class="line">    cout&lt;&lt;maxflow&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在某些情况下 EK 算法极其低效，其原因是：</p><ol type="1"><li><p>某些边被反复搜到又被反复退流；</p></li><li><p>每次只能搜到一条增广路，各次搜索之间相互独立。</p></li></ol><p>于是我们考虑使用新的算法。</p><h3 id="dinic-算法">Dinic 算法</h3><p><span class="math inline">\(O(n^2m)\)</span></p><h4 id="算法思想">算法思想：</h4><p>从上文中 EK 低效的原因出发：</p><p>针对第一点，发现每次去寻找最短增广路，可以避免绕路，从而也不会反复经过同一条边，此处的“短”，指经过的边数，而不指容量。我们可以想到对残量网络BFS 分层，这样就能找到最短的增广路径。</p><p>针对第二条，发现建立分层图之后我们可以使用 DFS对增广路进行搜索，每次找到增广路后回退到分叉点，可继续寻找下一条增广路，从而一次找到多条。</p><p>系统地阐述 Dinic 算法：</p><p>考虑在增广前先对 <span class="math inline">\(G_f\)</span> 做 BFS分层，即根据结点 <span class="math inline">\(u\)</span> 到源点 <spanclass="math inline">\(s\)</span> 的距离 <spanclass="math inline">\(d(u)\)</span> 把结点分成若干层。令经过 <spanclass="math inline">\(u\)</span> 的流量只能流向下一层的结点 <spanclass="math inline">\(v\)</span>，即删除 <spanclass="math inline">\(u\)</span> 向层数标号相等或更小的结点的出边，我们称 <spanclass="math inline">\(G_f\)</span> 剩下的部分为层次图。形式化地，我们称 <spanclass="math inline">\(G_L\)</span> 是 <spanclass="math inline">\(G_f\)</span> 的层次图，其中 $E_L = $ ${ (u, v) $$| (u, v) E_f, $ $d(u) + 1 = $ <span class="math inline">\(d(v)\}\)</span>。</p><p>如果我们在层次图 <spanclass="math inline">\(G_L\)</span> 上找到一个最大的增广流 <spanclass="math inline">\(f_b\)</span>，使得仅在 <spanclass="math inline">\(G_L\)</span> 上是不可能找出更大的增广流的，则我们称 <spanclass="math inline">\(f_b\)</span> 是 <spanclass="math inline">\(G_L\)</span> 的阻塞流。直观上理解阻塞流为在层次图的残量图中使得<span class="math inline">\(s\)</span> 与 <spanclass="math inline">\(t\)</span> 不连通的那个最大增广流。</p><h4 id="算法流程-1">算法流程：</h4><ol type="1"><li><p>在 <span class="math inline">\(G_f\)</span> 上 BFS 出层次图 <spanclass="math inline">\(G_L\)</span>。</p></li><li><p>在 <span class="math inline">\(G_L\)</span> 上 DFS 出阻塞流 <spanclass="math inline">\(f_b\)</span>。</p></li><li><p>将 <span class="math inline">\(f_b\)</span> 并到原先的 <spanclass="math inline">\(f\)</span> 中去。</p></li><li><p>重复以上过程直到不存在 <span class="math inline">\(s\)</span> 到<span class="math inline">\(t\)</span> 的路径。</p></li></ol><p>此时 <span class="math inline">\(f\)</span> 即为最大流。</p><h4 id="优化">优化：</h4><ol type="1"><li><p><strong>弧优化</strong>：</p><p>如果某一时刻我们已经知道边 <spanclass="math inline">\((u,v)\)</span> 已经增广到极限（边 <spanclass="math inline">\((u,v)\)</span> 已无剩余容量或 <spanclass="math inline">\(v\)</span> 的后侧已增广至阻塞），则 <spanclass="math inline">\(u\)</span> 的流量没有必要再尝试流向出边 <spanclass="math inline">\((u,v)\)</span>。据此，对于每个结点 <spanclass="math inline">\(u\)</span>，我们维护 <spanclass="math inline">\(u\)</span> 的出边表中第一条还有必要尝试的出边。称维护的这个指针为当前弧，称这个做法为当前弧优化。</p></li><li><p><strong>多路增广</strong>：</p><p>如果我们在层次图上找到了一条从 <spanclass="math inline">\(s\)</span> 到 <spanclass="math inline">\(t\)</span> 的增广路 <spanclass="math inline">\(p\)</span>，则接下来我们未必需要重新从 <spanclass="math inline">\(s\)</span> 出发找下一条增广路，而可能从 <spanclass="math inline">\(p\)</span> 上最后一个仍有剩余容量的位置出发寻找一条岔路进行增广。</p></li></ol><p>需要注意，弧优化是用于保证 Dinic算法正确性的一部分，而多路增广只是一个不影响复杂度的常数优化。</p><h4 id="复杂度分析">复杂度分析</h4><p>（参考文献：《浅谈基于分层思想的网络流算法》——王欣上2007国家集训队论文）</p><p>首先我们需要重新审视“层次图”的概念：一个点的层次即它在残量网络中到源点<span class="math inline">\(s\)</span>的最短路；层次图即是建立在残量网络中的最短路图。</p><p>Dinic算法的复杂度可以分为建立层次图和找增广路两部分。首先分析建立层次图的复杂度。</p><p>在这里我们需要给出一个定理：对于有 <spanclass="math inline">\(n\)</span> 个点的流量网络，层次图最多被建立 <spanclass="math inline">\(n\)</span>次。证明如下：一张网络中的边可以被划分为如下类型：一种是层次图中的边，一种是从某个层次较高的点出发连向层次较低的点的边，可以证明不会存在从某个点出发连向层次比它高且高度差大于<span class="math inline">\(1\)</span>的点的边，因为如果存在这样的边，便不满足层次图是“最短路图”的性质了。当我们对一条增广路径增广后，会删除一条或多条增广路径中的饱和边，并向剩余图给反向边增流，相当于我们会删去一些第一类边，并增添一些第二类边。找到阻塞流后，不存在从源点到汇点的增广路了，这时我们回看整个残量网络，如果还存在源点到汇点的路径，一定是从原点出发，沿第一类边走到某一点后跳转至第二类边，之后又走第一类边直到汇点，如果此前层次图的层数为<spanclass="math inline">\(k\)</span>，这条新找到的路径由于经过了第二类边，相当于在层次图中逆层跳转，此时这条路路径的长度一定大于<spanclass="math inline">\(k\)</span>，于是我们可得层次图中的增广路长度随阶段严格递增，而在<span class="math inline">\(n\)</span> 个点的图中，增广路的最短长度是<span class="math inline">\(1\)</span>，最长长度是 <spanclass="math inline">\(n-1\)</span>（链），还需要注意最后还会构建一次汇点不在图中的层次图来判定算法结束，所以层次图最多被构建<span class="math inline">\(n\)</span> 次，换而言之，Dinic 算法最多有<span class="math inline">\(n\)</span> 个阶段。</p><p>接下来分析一个阶段中找增广路的复杂度。</p><p>注意到每增广一次，层次图中必定有一条边被删除（满流或者后侧增广至阻塞流，这一条件与当前弧优化中弧指针转移条件相同，于是所谓删除就是指当前弧优化中弧指针的移动）。层次图中最多有<span class="math inline">\(m\)</span> 条边，所以增广最多进行 <spanclass="math inline">\(m\)</span> 次，在 DFS遍历时，存在前进与后退两种操作，如果当前路径的最后一个顶点能够继续扩展，则一定是沿着上文提及的层次图第一类边向汇点前进了一步。因为增广路径长度最长为<spanclass="math inline">\(n\)</span>，所以最多连续前进n步后就会遇到汇点，于是单次前进时间复杂度为<spanclass="math inline">\(O(n)\)</span>，类似地一次增广后在增广路中后退的时间复杂度上界也是<spanclass="math inline">\(O(n)\)</span>，所以一个阶段中寻找增广路的复杂度是<span class="math inline">\(O(m\times (n+n))=\)</span> <spanclass="math inline">\(O(mn)\)</span>。</p><p>综合上述两个阶段，Dinic 的时间复杂度是 阶段数 * 某阶段增广复杂度 即为<span class="math inline">\(O(n^2m)\)</span>。</p><h4 id="参考代码-1">参考代码：</h4><h5 id="vector版本-1">vector版本</h5><ol type="1"><li><p>变量声明与初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"><span class="type">int</span> maxflow;</span><br><span class="line"><span class="type">int</span> dep[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> from,to,cap,flow;&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; id[maxn];</span><br></pre></td></tr></table></figure></li><li><p>建图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge.<span class="built_in">push_back</span>(&#123;x,y,z,<span class="number">0</span>&#125;);</span><br><span class="line">    edge.<span class="built_in">push_back</span>(&#123;y,x,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    id[x].<span class="built_in">push_back</span>(edge.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    id[y].<span class="built_in">push_back</span>(edge.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BFS出层次图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s),dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id[u].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge e=edge[id[u][i]];</span><br><span class="line">            <span class="keyword">if</span>(dep[e.to]||e.flow&gt;=e.cap) <span class="keyword">continue</span>;</span><br><span class="line">            dep[e.to]=dep[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(e.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DFS寻找流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;id[u].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=id[u][i]; Edge e=edge[j];</span><br><span class="line">        <span class="keyword">if</span>(dep[e.to]!=dep[u]+<span class="number">1</span>||e.flow&gt;=e.cap) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">dfs</span>(e.to,<span class="built_in">min</span>(flow-ret,e.cap-e.flow));</span><br><span class="line">        <span class="keyword">if</span>(!d) dep[e.to]=<span class="number">0</span>;</span><br><span class="line">        ret+=d,edge[j].flow+=d,edge[j^<span class="number">1</span>].flow-=d;</span><br><span class="line">        <span class="keyword">if</span>(ret==flow) <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s,t))</span><br><span class="line">        maxflow+=<span class="built_in">dfs</span>(s,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="链式前向星版本-1">链式前向星版本</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v,w,maxflow,dep[<span class="number">1000</span>],cur[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> cnt,head[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> to,nxt,cap,flow;&#125; edge[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,head[x],z,<span class="number">0</span>&#125;;</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    edge[++cnt]=&#123;x,head[y],<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    head[y]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="built_in">sizeof</span>(dep));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s),dep[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge e=edge[i];</span><br><span class="line">            <span class="keyword">if</span>(dep[e.to]||e.flow&gt;=e.cap) <span class="keyword">continue</span>;</span><br><span class="line">            dep[e.to]=dep[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            <span class="keyword">if</span>(e.to==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="type">int</span> lst=Flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i&amp;&amp;lst;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge e=edge[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[e.to]!=dep[u]+<span class="number">1</span>||e.flow&gt;=e.cap) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">dinic</span>(e.to,<span class="built_in">min</span>(lst,e.cap-e.flow));</span><br><span class="line">        <span class="keyword">if</span>(!k) dep[e.to]=<span class="number">0</span>;</span><br><span class="line">        edge[i].flow+=k,edge[i^<span class="number">1</span>].flow-=k,lst-=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Flow-lst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t,cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,<span class="built_in">addin</span>(u,v,w);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>(s,t))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flow=<span class="built_in">dinic</span>(s,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        <span class="keyword">while</span>(flow) maxflow+=flow,flow=<span class="built_in">dinic</span>(s,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxflow&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isap-算法">ISAP 算法</h3><p>首先，ISAP 基于 Dinic。</p><h4 id="算法思想-1">算法思想</h4><p>在 Dinic 算法中，每次求完增广路中都要再跑 BFS来分层，在某些时候不够高效，ISAP的核心思想就是分层一次，之后再增广过程中完成重分层过程。</p><h4 id="算法流程-2">算法流程</h4><ol type="1"><li><p>先跑 BFS 对图上点进行分层，不过 BFS 方向是由 <spanclass="math inline">\(t\)</span> 向 <spanclass="math inline">\(s\)</span> （其意义参见第三步）。</p></li><li><p>增广，增广过程与 Dinic 类似，只选择层数多 <spanclass="math inline">\(1\)</span> 的进行增广。设 <spanclass="math inline">\(i\)</span> 号点的层数为 <spanclass="math inline">\(d_i\)</span>，在结束 <spanclass="math inline">\(i\)</span> 号点的增广过程后，若 <spanclass="math inline">\(i\)</span> 的流量未全部流出，遍历残量网络中 <spanclass="math inline">\(i\)</span> 的所有出边，找到层数最小的出点 <spanclass="math inline">\(j\)</span>，随后令 <spanclass="math inline">\(d_i=d_j+1\)</span>。特别地，若残量网络中 <spanclass="math inline">\(i\)</span> 无出边，令 <spanclass="math inline">\(d_i=n\)</span>（优化：最短路的修改具有连续性，即我们不需要每次求后继的标号最小值，而是直接给标号加一）。</p></li><li><p>当 <span class="math inline">\(d_s\geq n\)</span>时，图上不存在增广路，此时可终止算法。</p></li></ol><details class="note" open><summary>正确性证明</summary><p><p>某一个点接受一定量的流量，并向外推流。</p><p>根据上面的算法步骤，当一个点推流推完的时候，这个点的层数不提高。因为此时这个点的层数已经足够其推流了，不需要再提高，而且根据算法的要求，流量只能在相邻层之间移动。</p><p>假设当前点推流推不出去，需要提高层数，当前的点无法推流了，前面的点也无法推流，因此如果我们提高了这个点的层数，前面的点也必须要提高层数（否则无法推流），此时就能够保证至少这个点接受流量不变。</p><p>提高层数后，如果后面的点有层次更高的点，就可以继续推流，存在增广路；如果没有了，都是层次比较低的点，若这些点推流完毕没法提高层次，就会出现断层，满足算法结束条件。</p>综上，算法正确性成立。</p></details><h4 id="优化-1">优化</h4><p>和 Dinic 类似，ISAP 中也存在当前弧优化。</p><p>ISAP 还有另一个优化，我们记录层数为 <spanclass="math inline">\(i\)</span> 的点数量为 <spanclass="math inline">\(num_i\)</span>，每当将一个点的层数从 <spanclass="math inline">\(x\)</span> 更新到 <spanclass="math inline">\(y\)</span> 时，更新 <spanclass="math inline">\(num\)</span> 数组的值，若更新后 <spanclass="math inline">\(num_x=0\)</span>，意味着图中出现断层，此时无增广路，可直接终止算法，该优化被称为GAP 优化。</p><h4 id="代码实现">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v,w,cnt,head[<span class="number">100005</span>],dep[<span class="number">100005</span>],gap[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> to,nxt,flow;&#125; edge[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,head[x],w&#125;,head[x]=cnt;</span><br><span class="line">    edge[++cnt]=&#123;x,head[y],<span class="number">0</span>&#125;,head[y]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(t),dep[t]=<span class="number">1</span>,gap[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v),dep[v]=dep[u]+<span class="number">1</span>,gap[dep[v]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mxf;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t) &#123;mxf+=<span class="number">1ll</span>*f;<span class="keyword">return</span> f;&#125;</span><br><span class="line">    <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dep[v]+<span class="number">1</span>!=dep[u]||!edge[i].flow) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(edge[i].flow,f-lst));</span><br><span class="line">        <span class="keyword">if</span>(k) edge[i].flow-=k,edge[i^<span class="number">1</span>].flow+=k,lst+=k;</span><br><span class="line">        <span class="keyword">if</span>(lst==f) <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    --gap[dep[u]];</span><br><span class="line">    <span class="keyword">if</span>(gap[dep[u]]==<span class="number">0</span>) dep[s]=n+<span class="number">1</span>;</span><br><span class="line">    dep[u]++,gap[dep[u]]++;</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),s=<span class="built_in">rd</span>(),t=<span class="built_in">rd</span>(),cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(u,v,w);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">while</span>(dep[s]&lt;=n) <span class="built_in">dfs</span>(s,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="built_in">wt</span>(mxf),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二push-relabel-预流推进算法">二，Push-Relabel 预流推进算法</h2><p>该方法在求解过程中忽略流的守恒性，每次对一个结点更新答案以求最大流。</p><p><strong>超额流</strong>：对于一个结点，进入结点的流若超出流出结点的流，超出部分即为该结点的超额流<span class="math inline">\(e(u)\)</span>，形式化地，<spanclass="math inline">\(e(u)=\)</span> <spanclass="math inline">\(\sum_{(x,u)\in E}f(x,u)-\)</span> <spanclass="math inline">\(\sum_{(u,y)\in E}f(u,y)\)</span>。</p><p><strong>溢出</strong>：超额流 <spanclass="math inline">\(e(u)&gt;0\)</span> 时，称结点 <spanclass="math inline">\(u\)</span> 溢出（不包括 <spanclass="math inline">\(s\)</span> 与 <spanclass="math inline">\(t\)</span>）。</p><p>预流推进算法维护每个结点的高度 <spanclass="math inline">\(h(u)\)</span>，并且规定溢出的结点 <spanclass="math inline">\(u\)</span> 如果要推送超额流，只能向高度小于 <spanclass="math inline">\(u\)</span> 的结点推送；如果 <spanclass="math inline">\(u\)</span> 没有相邻的高度小于 <spanclass="math inline">\(u\)</span> 的结点，那就修改 <spanclass="math inline">\(u\)</span> 的高度。</p><h3 id="相关操作">1. 相关操作</h3><ol><li><p><strong>高度函数</strong>：维护一个高度映射 <spanclass="math inline">\(h\)</span>。</p><ol><li><p><span class="math inline">\(h(s)=|V|,\)</span> <spanclass="math inline">\(h(t)=0\)</span></p></li><li><p><span class="math inline">\(\forall (u,v)\in E_f,\)</span> <spanclass="math inline">\(h(u)\leq h(v)+1\)</span></p></li></ol><p>称为 <span class="math inline">\(h\)</span> 是残量网络 <spanclass="math inline">\(G_f=(V_f,E_f)\)</span> 的高度函数。</p><p>引理：设 <span class="math inline">\(G_f\)</span> 上的高度函数为<span class="math inline">\(h\)</span>，对于任意两个节点 <spanclass="math inline">\(u,v\in V\)</span>，如果 <spanclass="math inline">\(h(u)&gt;h(v)+1\)</span>，则 <spanclass="math inline">\((u,v)\)</span> 不是 <spanclass="math inline">\(G_f\)</span> 中的边。</p></li><li><p><strong>推送</strong>：将超额流从 <span class="math inline">\(u\)</span>推送到 <span class="math inline">\(v\)</span>。</p><p>条件：点 <span class="math inline">\(u\)</span> 溢出，点 <spanclass="math inline">\(v\)</span> 满足 <spanclass="math inline">\((u,v)\in E_f,\)</span> <spanclass="math inline">\(c(u,v)&gt;f(u,v),\)</span> <spanclass="math inline">\(h(u)=h(v)+1\)</span>。</p><p>如果 <span class="math inline">\((u,v)\)</span>在推送完之后满流，将其从残量网络中删除。</p></li><li><p><strong>重贴标签</strong>：将 <span class="math inline">\(h(u)\)</span>更新为 <span class="math inline">\(\min_{(u,v)\in E_f}h(v)+1\)</span>。</p><p>条件：结点 <span class="math inline">\(u\)</span> 溢出，且 <spanclass="math inline">\(\forall (u,v)\in E_f,\)</span> <spanclass="math inline">\(h(u)&lt;h(v)\)</span>。</p></li><li><p><strong>初始化</strong>：<p><span class="math inline">\(1. \forall (u,v)\in E,\)</span> <spanclass="math inline">\(f(u,v)={  \begin{cases}c(u,v),u=s\\  0,u\neqs\\  \end{cases} }\)</span></p><p><span class="math inline">\(2. \forall u\in V,\)</span> <spanclass="math inline">\(h(u)={  \begin{cases}|V|,u=s\\  0,u\neqs\\  \end{cases}\}\)</span></p><p><span class="math inline">\(3. e(u)=\)</span> <spanclass="math inline">\(\sum_{(x,u)\in E}f(x,u)-\)</span> $_{(u,y)E}f(u,y)$</p></p></li></ol><h3 id="过程及暴力实现">2. 过程及暴力实现</h3><p>每次扫描整个图，存在结点 <span class="math inline">\(u\)</span> 满足push 或 relabel 操作的条件则执行对应操作。</p><p>考虑暴力实现：暴力扫描是否有溢出的结点，有就更新。</p><ol type="1"><li><p>变量声明及建图：略</p></li><li><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[s];ili=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge e=edge[i];</span><br><span class="line">        ex[e.to]=e.flow,ex[s]-=ex[e.to];</span><br><span class="line">        edge[i].flow=<span class="number">0</span>,edge[i^<span class="number">1</span>].flow=e.flow;</span><br><span class="line">    &#125;</span><br><span class="line">    h[s]=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>推送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=edge[i^<span class="number">1</span>].to,v=edge[i].to,flow=<span class="built_in">max</span>(ex[u],edge[i].flow);</span><br><span class="line">    ex[u]-=flow,ex[v]+=flow;</span><br><span class="line">    edge[i].flow-=flow,edge[i^<span class="number">1</span>].flow+=flow;</span><br><span class="line">    <span class="keyword">return</span> ex[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重贴标签</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">relabel</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[u]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(edge[i].flow) h[u]=<span class="built_in">min</span>(h[u],h[edge[i].to]);</span><br><span class="line">    ++h[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="hlpp-算法">3. HLPP 算法</h3><p><span class="math inline">\(O(n^2\sqrt{m})\)</span></p><p>在上述过程基础上，优先选择高度最高的溢出结点。</p><h4 id="算法流程-3">算法流程：</h4><ol type="1"><li><p>初始化</p></li><li><p>选择溢出结点中高度最高的结点并推送</p></li><li><p>如果2中的点仍溢出，重贴标签并回到2</p></li><li><p>没有溢出结点时结束</p></li></ol><h4 id="优化-2">优化：</h4><ol type="1"><li><p><strong>BFS 优化</strong>：</p><p>初始化时使用 BFS，初始化 <span class="math inline">\(h(u)\)</span> 为<span class="math inline">\(u\)</span> 到 <spanclass="math inline">\(t\)</span> 的最短距离，特别地使 <spanclass="math inline">\(h(s)=n\)</span>。</p><p>在BFS的同时检查连通性排除无解情况。</p></li><li><p><strong>GAP 优化</strong>：</p><p>如果某一时刻 <span class="math inline">\(h(u)=t\)</span> 的结点个数为<span class="math inline">\(0\)</span>，将 <spanclass="math inline">\(h(u)&gt;t\)</span> 的结点高度变为至少 <spanclass="math inline">\(n+1\)</span> 以便尽快推送回 <spanclass="math inline">\(s\)</span>，减少重贴标签次数。</p></li></ol><h4 id="参考代码-2">参考代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s,t,u,v,w;</span><br><span class="line"><span class="type">int</span> h[<span class="number">2000</span>],c[<span class="number">2000</span>],num[<span class="number">2000</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>,head[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> to,nxt,val;&#125; edge[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt]=&#123;y,head[x],z&#125;,head[x]=cnt;</span><br><span class="line">    edge[++cnt]=&#123;x,head[y],<span class="number">0</span>&#125;,head[y]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> stop;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; b[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(t),h[t]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(edge[i^<span class="number">1</span>].val&amp;&amp;h[v]&gt;h[u]+<span class="number">1</span>)</span><br><span class="line">                h[v]=h[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[s]!=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!edge[i].val||(u!=s&amp;&amp;h[u]!=h[v]+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(v!=s&amp;&amp;v!=t&amp;&amp;!c[v]) b[h[v]].<span class="built_in">push</span>(v),stop=<span class="built_in">max</span>(stop,h[v]);</span><br><span class="line">        <span class="type">int</span> d=(u==s)?edge[i].val:<span class="built_in">min</span>(edge[i].val,c[u]);</span><br><span class="line">        c[u]-=d,c[v]+=d,edge[i].val-=d,edge[i^<span class="number">1</span>].val+=d;</span><br><span class="line">        <span class="keyword">if</span>(!c[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relabel</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[u]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class="line">        <span class="keyword">if</span>(edge[i].val) h[u]=<span class="built_in">min</span>(h[u],h[edge[i].to]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(h[u]&gt;=n) <span class="keyword">return</span>;</span><br><span class="line">    b[h[u]].<span class="built_in">push</span>(u),stop=<span class="built_in">max</span>(stop,h[u]),++num[h[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findtop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(b[stop].<span class="built_in">size</span>()==<span class="number">0</span>&amp;&amp;stop&gt;<span class="number">-1</span>) stop--;</span><br><span class="line">    <span class="keyword">return</span> stop==<span class="number">-1</span>?<span class="number">0</span>:b[stop].<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hlpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">init</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(h[i]!=<span class="number">0x3f3f3f3f</span>) ++num[h[i]];</span><br><span class="line">    h[s]=n,<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="built_in">findtop</span>();u;u=<span class="built_in">findtop</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        b[stop].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">push</span>(u)) <span class="keyword">continue</span>;</span><br><span class="line">        --num[h[u]];</span><br><span class="line">        <span class="keyword">if</span>(!num[h[u]]) </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">if</span>(i!=s&amp;&amp;i!=t&amp;&amp;h[i]&gt;h[u]&amp;&amp;h[i]&lt;=n) h[i]=n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">relabel</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,<span class="built_in">addin</span>(u,v,w);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">hlpp</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三习题">三，习题</h2><p>若无特殊情况，所有习题均只给出主函数建图代码，其余代码套用模板</p><h3><a href="https://www.luogu.com.cn/problem/P1343">洛谷P1343 地震逃生</a></h3><p>每次通过的人数即为最大流，通过的批次即为总人数与单次人数之商上取整。当最大流为<span class="math inline">\(0\)</span> 的时候，说明无法逃离至 <spanclass="math inline">\(n\)</span> 点，此时输出无解即可。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>()；</span><br><span class="line">s=<span class="number">1</span>,t=n,cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    u=<span class="built_in">rd</span>(),v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(u,v,w);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(mxf==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;Orz Ni Jinan Saint Cow!&quot;</span>&lt;&lt;endl,<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">tot=x/mxf+(x%mxf?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line"><span class="built_in">wt</span>(mxf),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>),<span class="built_in">wt</span>(tot);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P1402">洛谷P1402 酒店之王</a></h3><p>十分经典的建图思路，将每个客户拆为两个点，代表两个需求，一个与房间代表的点相连，容量为是否喜欢，另一个点与食物代表的点相连，容量为是否喜欢，之后建立超级源点和超级汇点，超级源点连所有房间，容量为<span class="math inline">\(1\)</span>代表可选但只可选一次，所有食物连向汇点，容量也为 <spanclass="math inline">\(1\)</span>，求最大流即可。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">rd</span>(),p=<span class="built_in">rd</span>(),q=<span class="built_in">rd</span>(),s=<span class="number">0</span>,t=<span class="number">2</span>*n+p+q+<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++) <span class="built_in">addin</span>(s,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j++)</span><br><span class="line">w=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(j,i+p,w);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">addin</span>(i+p,i+p+n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=q;j++)</span><br><span class="line">w=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(i+p+n,j+p+<span class="number">2</span>*n,w);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">addin</span>(i+p+<span class="number">2</span>*n,t,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P3254">洛谷P3254 圆桌问题</a></h3><p>此题可以贪心，但在此不做讲解。</p><p>考虑将各单位与桌子相连，边权为 <span class="math inline">\(1\)</span>代表该单位至多派一个人到该桌子，之后建立超级源汇点，将源点与单位连，容量为人数，桌子与汇点连，容量为可容纳人数，之后跑最大流即可。若最大流不等于总人数，说明无解。统计方案时对于每个单位遍历其出边，发现饱和边后输出对应桌子即可。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="built_in">rd</span>(),n=<span class="built_in">rd</span>(),s=<span class="number">0</span>,t=n+m+<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) w=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(s,i,w),sum+=w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="built_in">addin</span>(i,j+m,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) w=<span class="built_in">rd</span>(),<span class="built_in">addin</span>(i+m,t,w);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(mxf!=sum) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>),<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=e[j].nxt)</span><br><span class="line"><span class="keyword">if</span>(e[j].flow==<span class="number">0</span>) <span class="built_in">wt</span>(e[j].to-m),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P4174">洛谷P4174 最大获利</a></h3><p>首先对某一个用户群中，只有同时选中两个中转站才有获益，一件事要发生，它需要的所有前提条件也要发生，在图论中这种任意点的任意后继一定在图中的图叫闭合图，此题即为一个最大权闭合图问题，建立一个超级源点和超级汇点，将源点连向所有中转站，容量为建造费用，将用户群转化为点，连向超级汇点，容量为获益。原图中的边容量为正无穷，跑一遍最大流。一条由源点向汇点的增广路可以被分为三段：源点-中转站，中转站-用户，用户-汇点，其中中转站-用户容量为正无穷，对最大流没有贡献，考虑剩下两段中哪段成为了该条增广路的最大流。如果源点-中转站是最大流，相当于收益大于代价，此时要建造中转站；如果用户-汇点是最大流，相当于代价大于收益，此时不建造中转站。先求出所有用户群都选中的总收益，回看以上两种情况，对于前者，付出了中转站的建造代价，可以看作总收益中的损失；对于后者，失去了该用户群的收益，也可以看作是总收益的损失。推广到整个图中，最终答案就是总收益与最大流的差值。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;n&gt;&gt;m,s=<span class="number">0</span>,t=n+m+<span class="number">1</span>,cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;p,<span class="built_in">addin</span>(s,i,p);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w,sum+=w;</span><br><span class="line"><span class="built_in">addin</span>(i+n,t,w),<span class="built_in">addin</span>(u,i+n,inf),<span class="built_in">addin</span>(v,i+n,inf);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">cout&lt;&lt;sum-maxflow&lt;&lt;endl;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流概览重制版</title>
      <link href="/2023/06/19/%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A6%82%E8%A7%88%E9%87%8D%E5%88%B6%E7%89%88/"/>
      <url>/2023/06/19/%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A6%82%E8%A7%88%E9%87%8D%E5%88%B6%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流概览">网络流概览</h1><p>网络流是一种类比水流解决问题的办法。</p><h2 id="一相关概念">一，相关概念</h2><p>网络：指一张有向图 <span class="math inline">\(G=(V,E)\)</span>；</p><p>弧：即网络中的有向边。</p><p>容量：网络中每条边的权值，即 <span class="math inline">\((u,v)\inE\)</span> 的权值 <span class="math inline">\(c(u,v)\)</span>。规定当<span class="math inline">\((u,v)\notin E\)</span> 时，<spanclass="math inline">\(c(u,v)=0\)</span>，也就是说 <spanclass="math inline">\(u\)</span> 无法向 <spanclass="math inline">\(v\)</span> 出流。</p><p>流量：在网络中每条边都有一个流量，用 <spanclass="math inline">\(f(u,v)\)</span>表示，可以是负值。下文会详细介绍其性质。</p><p>残留容量：也称剩余容量，每条边除流量以外的容量，即残余容量=容量-流量。</p><p>源点：网络流的出发点 <span class="math inline">\(s\)</span>，<spanclass="math inline">\(s\)</span> 向外释放流量，<spanclass="math inline">\(s\in V\)</span>。</p><p>汇点：网络流的结束点 <span class="math inline">\(t\)</span>，<spanclass="math inline">\(t\)</span> 接受流量，<spanclass="math inline">\(t\in V\)</span>。</p><p>源点只释放流量，汇点只接受流量，其余点可以接受流量，但必须释放等量的流量。于是我们可以具象地理解一下网络流：网络即自来水系统，容量就是水管的最大水流量，源点是一个可无限出水的自来水厂，汇点是一个可无限接受水流的小区，其他结点起中转作用。可以想到一条自来水路线中最大的水流就等于水流量最小管道的水流量，若路线水流比该管道的水流量大，该管道无法接受。</p><p>容量网络：拥有源点汇点，且每条边都给出容量的网络。</p><p>流量网络：拥有源点汇点，且每条边都给出流量的网络。</p><p>残量网络：拥有源点汇点，且每条边都有残余容量的网络，残量网络=容量网络-流量网络。</p><h2 id="二流及其性质">二，流及其性质</h2><p>对于一个流 <spanclass="math inline">\(f(u,v)\)</span>，其满足如下性质：</p><ol type="1"><li><p>容量限制：每条边的流量 <spanclass="math inline">\(f(u,v)\)</span> 不得超过其容量 <spanclass="math inline">\(c(u,v)\)</span>。</p></li><li><p>斜对称性：每条边的流量与其反向边的流量互为相反数。即 <spanclass="math inline">\(f(u,v)=-f(v,u)\)</span>。</p></li><li><p>流守恒性：从源点出发的流量等于汇点流入的流量，其余点的出发流量等于其自身的流入流量。即<span class="math inline">\(\forall x\in V-\)</span> <spanclass="math inline">\(\{s,t\},\)</span> <spanclass="math inline">\(\sum_{(u,x)\in E}f(u,x)=\)</span> <spanclass="math inline">\(\sum_{(x,v)\in E}f(x,v)\)</span>。</p></li></ol><details class="note" open><summary>在此给出第二条性质的解释</summary><p>如果我们认为由 <span class="math inline">\(u\)</span> 流向 <spanclass="math inline">\(v\)</span> 为正向的，那么由 <spanclass="math inline">\(v\)</span> 流向 <spanclass="math inline">\(u\)</span> 便是反向，正向中由 <spanclass="math inline">\(u\)</span> 流向 <spanclass="math inline">\(v\)</span> 的流量为 <spanclass="math inline">\(f(u,v)\)</span>，那么我们可以认为这相当于其向反向流了<span class="math inline">\(-f(u,v)\)</span> 的流量，即 <spanclass="math inline">\(f(v,u)=-f(u,v)\)</span>。</p></details><p>称 <span class="math inline">\(f\)</span> 为网络 <spanclass="math inline">\(G\)</span> 的流函数，整个网络的流量为 <spanclass="math inline">\(\sum_{(s,v)\inE}f(s,v)\)</span>，即从源点出发的所有流量之和。</p><p>现在我们可以给出流函数的形式化定义:</p><p>$ f(u,v)=$ <span class="math inline">\({  \begin{cases}f(u,v),(u,v)\inE\\  -f(v,u),(v,u)\in E\\  0,(u,v)\notin E,(v,u)\notin E\end{cases}}\)</span></p><h2 id="三网络流相关问题">三，网络流相关问题</h2><p>在前文引言部分提到了网络流是一种类比水流解决问题的方法，以下为一些网络流的常见问题：</p><h3 id="最大流">1. 最大流</h3><p>给出一个网络，求源点流向汇点的最大流量。其求法与最短路的求法有些许相似之处，都会用到增广路的思想，详情请见<ahref="https://intconstlee.github.io/posts/max-flows/">最大流</a>或<ahref="https://intconstlee.github.io/posts/max-flows-remake/">最大流重制版</a>。</p><h3 id="最小费用最大流">2. 最小费用最大流</h3><p>在最大流问题的基础上给每条边增加一个费用，在求最大流的同时使得花费最小，详情请见<ahref="https://intconstlee.github.io/posts/minimal-cut/">最小割</a>。</p><h3 id="最小割">3. 最小割</h3><p>割，即删。最小割问题要求在网络中删除一些边使得 <spanclass="math inline">\(s\)</span> 与 <spanclass="math inline">\(t\)</span>不互通，并且删去的边流量之和最小，详情请见<ahref="https://intconstlee.github.io/posts/minimal-cost-flows/">费用流</a>（目前还未完善）</p><h3 id="上下界网络流">4. 上下界网络流</h3><p>每条边给定了流量上界与下界，根据题目要求问题也有所不同。（新建文件夹中……）</p><p>在网络流学习中可能会遇到许多抽象的概念或性质或思想，但可以勤思考，运用类比思想具象化，笔者也会尽量给出相关理解或证明。</p>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化</title>
      <link href="/2023/06/15/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
      <url>/2023/06/15/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="斜率优化">斜率优化</h1><p>斜率优化的核心在于推导状态转移方程使之变为斜率一定的一次函数，使<span class="math inline">\(f[i]\)</span> 与截距相关，将求 <spanclass="math inline">\(f[i]\)</span>最值转化为用一条定斜率的直线去过平面上的点，使截距取到最值。</p><h2 id="一引入">一，引入</h2><h3 id="d-动态规划模型">1D 动态规划模型</h3><p>1D 动态规划模型是 DP中一类非常基本、非常重要的模型，所求的是最优化问题，1D动态规划可大致归纳为如下形式</p><p><span class="math inline">\(F[i]=\)</span> <spanclass="math inline">\(min_{L(i)\leq j\leq R(i)}\)</span> <spanclass="math inline">\((F[j]+\)</span> <spanclass="math inline">\(val(i,j))\)</span></p><p>接下来对这一通式进行解读。<span class="math inline">\(F[i]\)</span>和 <span class="math inline">\(F[j]\)</span> 代表 DP 数组，<spanclass="math inline">\(L(i)\)</span> 和 <spanclass="math inline">\(R(i)\)</span> 是关于变量 <spanclass="math inline">\(i\)</span> 的一次函数，用于划定 <spanclass="math inline">\(j\)</span> 的上下界，<spanclass="math inline">\(val(i,j)\)</span> 为一个关于变量 <spanclass="math inline">\(i\)</span> 和变量 <spanclass="math inline">\(j\)</span> 的多项式函数，也是 DP优化的关键所在。</p><h3 id="状态转移中的斜率">状态转移中的斜率</h3><p>对于一个 1D 动态规划问题，列出其状态转移，发现 <spanclass="math inline">\(val(i,j)\)</span> 中包含 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(j\)</span> 的乘积项。最简单的形如</p><p><span class="math inline">\(F[i]=\)</span> <spanclass="math inline">\(F[j]+\)</span> <spanclass="math inline">\(b_ib_j\)</span> <spanclass="math inline">\(\Longleftrightarrow\)</span> <spanclass="math inline">\(F[j]=\)</span> <spanclass="math inline">\(-b_ib_j+\)</span> <spanclass="math inline">\(F[i]\)</span></p><p>发现 <span class="math inline">\(F[j]\)</span> 的表达形如 <spanclass="math inline">\(F[j]=kb_j+b\)</span>，为一个一次函数，斜率为 <spanclass="math inline">\(-b_i\)</span>。与直线 <spanclass="math inline">\(b_j=0\)</span> 的截距即为 <spanclass="math inline">\(F[i]\)</span>。斜率优化将动态规划转化为数学中的线性规划问题。下文将详细讲解。</p><h2 id="二思路">二，思路</h2><details class="note" open><summary>例题：任务安排</summary><p><p>有 <span class="math inline">\(N\)</span> 个有序任务，第 <spanclass="math inline">\(i\)</span> 个任务耗时 <spanclass="math inline">\(T_i\)</span>，费用系数 <spanclass="math inline">\(C_i\)</span>，将任务分组顺序执行，执行每组前需要<span class="math inline">\(S\)</span>的启动时间，一组中的所有任务将顺序执行，每个任务的完成时刻是其所在组全部任务的完成时刻，每个任务的花费是完成时刻乘费用系数。求最小总费用。</p><p>对于 <span class="math inline">\(T\)</span> 和 <spanclass="math inline">\(C\)</span>，可以求出前缀和数组 <spanclass="math inline">\(sumT,sumC\)</span>，<spanclass="math inline">\(F[i][j]\)</span> 表示将前 <spanclass="math inline">\(i\)</span> 个任务分成 <spanclass="math inline">\(j\)</span> 批执行的最小费用，第 <spanclass="math inline">\(j\)</span> 批任务的完成时刻是 <spanclass="math inline">\(j\times S+sumT[i]\)</span>，状态转移方程如下：</p><p><span class="math inline">\(F[i][j]=\)</span> <spanclass="math inline">\(min_{0\leq k&lt;i}\)</span> <spanclass="math inline">\((F[k][j-1]+\)</span> <spanclass="math inline">\((S\times\)</span> <spanclass="math inline">\(j+\)</span> <spanclass="math inline">\(sumT[i])\times\)</span> <spanclass="math inline">\((sumC[i]-\)</span> <spanclass="math inline">\(sumC[k]))\)</span></p><p>直接 DP，复杂度为 <spanclass="math inline">\(O(N^3)\)</span>，考虑优化。</p></p></details><h3 id="优化一费用提前计算">优化一：费用提前计算</h3><p>在刚才的状态转移方程中，我们需要 <spanclass="math inline">\(j\)</span>仅仅是为了判断启动了多少次，发现如果没有 <spanclass="math inline">\(j\)</span>，不易得启动了多少次，但可以知道每次启动时间<span class="math inline">\(S\)</span>都会累加到此后所有任务的完成时刻中，于是 DP 数组可以维度压缩，设 <spanclass="math inline">\(F[i]\)</span> 表示把前 <spanclass="math inline">\(i\)</span> 个元素分若干批完成的最小费用，则：</p><p><span class="math inline">\(F[i]=\)</span> <spanclass="math inline">\(min_{0\leq j&lt;i}\)</span> <spanclass="math inline">\((F[j]+\)</span> <spanclass="math inline">\(sumT[i]\times\)</span> <spanclass="math inline">\((sumC[i]-\)</span> <spanclass="math inline">\(sumC[j])+\)</span> <spanclass="math inline">\(S\times\)</span> <spanclass="math inline">\((sumC[N]-\)</span> <spanclass="math inline">\(sumC[j]))\)</span></p><p>发现在这一转移方程中，我们把之后的费用提前累加到了答案中，这种“费用提前计算”是一种经典思想。于是时间复杂度可以降至<span class="math inline">\(O(N^2)\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">5005</span>],sumt[<span class="number">5005</span>],sumc[<span class="number">5005</span>];</span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,c;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;c;</span><br><span class="line">        sumt[i]=sumt[i<span class="number">-1</span>]+t;</span><br><span class="line">        sumc[i]=sumc[i<span class="number">-1</span>]+c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            f[i]=<span class="built_in">min</span>(f[i],f[j]+sumt[i]*(sumc[i]-sumc[j])+s*(sumc[n]-sumc[i]));</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="优化二斜率优化">优化二：斜率优化</h3><p>在费用提前计算的基础上进一步优化，对状态转移方程变形得：</p><p><span class="math inline">\(F[i]=\)</span> <spanclass="math inline">\(min_{0\leq j&lt;i}\)</span> <spanclass="math inline">\((F[j]-\)</span> <spanclass="math inline">\(sumC[j]\times\)</span> <spanclass="math inline">\((sumT[i]+\)</span> <spanclass="math inline">\(S)+\)</span> <spanclass="math inline">\(sumT[i]\times\)</span> <spanclass="math inline">\(sumC[i]+\)</span> <spanclass="math inline">\(S\times\)</span> <spanclass="math inline">\(sumC[N]))\)</span></p><p>把 <span class="math inline">\(min\)</span> 函数去掉，将关于 <spanclass="math inline">\(j\)</span> 的值 <spanclass="math inline">\(F[j]\)</span> 和 <spanclass="math inline">\(sumC[j]\)</span>看作变量，其余部分作为常量，得到</p><p><span class="math inline">\(F[j]=\)</span> <spanclass="math inline">\((sumT[i]+\)</span> <spanclass="math inline">\(S)\times\)</span> <spanclass="math inline">\(sumC[j]+\)</span> <spanclass="math inline">\(F[i]-\)</span> <spanclass="math inline">\(sumT[i]\times\)</span> <spanclass="math inline">\(sumC[i]-\)</span> <spanclass="math inline">\(S\times\)</span> <spanclass="math inline">\(sumC[N]\)</span></p><p>在以 <span class="math inline">\(sumC[j]\)</span> 为横坐标，<spanclass="math inline">\(F[j]\)</span>为纵坐标的平面直角坐标系中，这是一条以 <spanclass="math inline">\((sumT[i]+\)</span> <spanclass="math inline">\(S)\)</span> 为斜率，以 <spanclass="math inline">\(F[i]-\)</span> <spanclass="math inline">\(sumT[i]\times\)</span> <spanclass="math inline">\(sumC[i]-\)</span> <spanclass="math inline">\(S\times\)</span> <spanclass="math inline">\(sumC[N]\)</span>为截距的直线。其中斜率为已知量，截距中除 <spanclass="math inline">\(F[i]\)</span>外均为已知量。则候选决策为坐标中的点集，每个 <spanclass="math inline">\(j\)</span> 对应一个 <spanclass="math inline">\((sumC[j],F[j])\)</span>，而每个 <spanclass="math inline">\(F[i]\)</span> 也都对应了一个截距，当截距最小时<span class="math inline">\(F[i]\)</span> 取到最小值。</p><p>于是 DP 问题就被转化为了这样一个线性规划问题</p><center><img src="https://oi-wiki.org/dp/images/optimization.svg" width=60%>示例</img></center><p>用一条斜率已知的直线去过平面直角坐标系内的点，使截距最小，发现若这条斜线从下向上平移，接触到第一个点时截距最小。通过推导公式或画图直观感受，我们会发现第一个被斜线接触的点有特殊性质，假设该点为<span class="math inline">\(j_2\)</span>，该点左侧有 <spanclass="math inline">\(j_1\)</span>，右侧有 <spanclass="math inline">\(j_3\)</span>，则</p><p><spanclass="math inline">\(\frac{F[j_2]-F[j_1]}{sumC[j_2]-sumC[j_1]}&lt;\)</span><spanclass="math inline">\(\frac{F[j_3]-F[j_2]}{sumC[j_3]-sumC[j_2]}\)</span></p><p>发现这两个式子恰好斜率，于是我们可以想到要维护一个下凸壳，使所有点包含在这个凸壳内，令直线截距最小的点一定在这个下凸壳上，且两侧斜率一侧大于直线斜率，一侧小于直线斜率。</p><p>接下来只要解决如何维护这个凸壳即可。发现对于凸壳，其斜率单调变化，于是可以建立单调队列来维护，每插入一个点时，将队尾不符合单调性的点弹出，使之被包在凸壳内。</p><p>在本题我们发现斜率 <span class="math inline">\(S+sumT[i]\)</span>单调递增，所以可以每次把队头斜率小于此的弹出，然后取队头即可，若斜率不满足单调递增，则答案不一定在队头，在队列中二分查找即可。</p><p>整个算法时间复杂度为 <span class="math inline">\(O(N)\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,c;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;c;</span><br><span class="line">        T[i]=T[i<span class="number">-1</span>]+t,C[i]=C[i<span class="number">-1</span>]+c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">1</span>]=<span class="number">0</span>;;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;(f[q[l+<span class="number">1</span>]]-f[q[l]])&lt;=(s+T[i])*(C[q[l+<span class="number">1</span>]]-C[q[l]]))</span><br><span class="line">            l++;</span><br><span class="line">        f[i]=f[q[l]]-C[q[l]]*(s+T[i])+T[i]*C[i]+s*C[i];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;(f[q[r]]-f[q[r<span class="number">-1</span>]])*(C[i]-C[q[r]])&gt;=(f[i]-f[q[r]])*(C[q[r]]-C[q[r<span class="number">-1</span>]]))</span><br><span class="line">            r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="三总结">三，总结</h2><p>概述斜率优化的算法：</p><ol type="1"><li>将初始状态入队；</li><li>每次使用一条和 <span class="math inline">\(i\)</span> 相关的直线<span class="math inline">\(f[i]\)</span>取切维护的凸壳，找到最优策略，更新 <spanclass="math inline">\(dp_i\)</span>；</li><li>保证单调性地加入状态 <spanclass="math inline">\(dp_i\)</span>。</li></ol><p>斜率优化题目的主要难点在于状态转移方程的推导变形，以及对单调性的判断。</p><h2 id="四习题">四，习题</h2><h3><a href="https://www.luogu.com.cn/problem/P3195">洛谷P3195 玩具装箱</a></h3><p><span class="math inline">\(O(n)\)</span> 做法：设 <spanclass="math inline">\(f[i]\)</span> 表示前 <spanclass="math inline">\(i\)</span>个物品被分为若干组，列出状态转移方程：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(min_{0\leq j&lt;i}(f[j]+\)</span> <spanclass="math inline">\((sum[i]-\)</span> <spanclass="math inline">\(sum[j]+\)</span> <spanclass="math inline">\(i-\)</span> <spanclass="math inline">\(j-\)</span> <spanclass="math inline">\(l-\)</span> <spanclass="math inline">\(1)^2)\)</span>，去掉 <spanclass="math inline">\(min\)</span> 函数得：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(f[j]+\)</span> <spanclass="math inline">\(((sum[i]+\)</span> <spanclass="math inline">\(i-\)</span> <spanclass="math inline">\(l-\)</span> <spanclass="math inline">\(1)-\)</span> <spanclass="math inline">\((sum[j]-\)</span> <spanclass="math inline">\(j))^2\)</span>。设 <spanclass="math inline">\(a_i=\)</span> <spanclass="math inline">\(sum[i]+\)</span> <spanclass="math inline">\(i-\)</span> <spanclass="math inline">\(l-\)</span> <spanclass="math inline">\(1\)</span>，设 <spanclass="math inline">\(a_j=\)</span> <spanclass="math inline">\(sum[j]-\)</span> <spanclass="math inline">\(j\)</span>，则有：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(f[j]+\)</span> <spanclass="math inline">\((a_i-\)</span> <spanclass="math inline">\(a_j)^2=\)</span> <spanclass="math inline">\(f[j]+\)</span> <spanclass="math inline">\(a_i^2+\)</span> <spanclass="math inline">\(a_j^2+\)</span> <spanclass="math inline">\(2a_ia_j\)</span>，移项，得到：<spanclass="math inline">\(f[j]+a_j^2=-2a_ia_j-a_i^2+f[i]\)</span>，可用斜率优化，套用斜率优化模板即可。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,s,q[<span class="number">50005</span>];</span><br><span class="line">ll c[<span class="number">50005</span>],f[<span class="number">50005</span>];</span><br><span class="line"><span class="function">ll <span class="title">y</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x]+c[x]*c[x];&#125;</span><br><span class="line"><span class="function">ll <span class="title">k</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>*(c[x]-s);&#125;</span><br><span class="line"><span class="function">ll <span class="title">d</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> (c[x]-s)*(c[x]-s);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),s=<span class="built_in">rd</span>(),s++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]=<span class="built_in">rd</span>(),c[i]+=c[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)                                </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">y</span>(q[l+<span class="number">1</span>])-<span class="built_in">y</span>(q[l])&lt;=(c[q[l+<span class="number">1</span>]]-c[q[l]])*<span class="built_in">k</span>(i)) l++;</span><br><span class="line">        f[i]=<span class="built_in">y</span>(q[l])-<span class="built_in">k</span>(i)*c[q[l]]+<span class="built_in">d</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;(<span class="built_in">y</span>(q[r])-<span class="built_in">y</span>(q[r<span class="number">-1</span>]))*(c[i]-c[q[r]])&gt;=(<span class="built_in">y</span>(i)-<span class="built_in">y</span>(q[r]))*(c[q[r]]-c[q[r<span class="number">-1</span>]])) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wt</span>(f[n]),<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P3628">洛谷P3628特别行动队</a></h3><p><span class="math inline">\(O(n)\)</span> 做法：设 <spanclass="math inline">\(f[i]\)</span> 表示前 <spanclass="math inline">\(i\)</span>个士兵被分为若干组，列出状态转移方程：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(min_{0\leq j&lt;i}(f[j]+\)</span> <spanclass="math inline">\(a(sum[i]-\)</span> <spanclass="math inline">\(sum[j])^2+\)</span> <spanclass="math inline">\(b(sum[i]-\)</span> <spanclass="math inline">\(sum[j])+\)</span> <spanclass="math inline">\(c)\)</span>，去掉 <spanclass="math inline">\(min\)</span> 函数得：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(f[j]+\)</span> <spanclass="math inline">\(a(sum[i]-\)</span> <spanclass="math inline">\(sum[j])^2+\)</span> <spanclass="math inline">\(bsum[i]-\)</span> <spanclass="math inline">\(bsum[j]+\)</span> <spanclass="math inline">\(c\)</span>，开方得：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(f[j]+\)</span> <spanclass="math inline">\(asum[i]^2+\)</span> <spanclass="math inline">\(asum[j]^2-\)</span> <spanclass="math inline">\(2asum[i]sum[j]+\)</span> <spanclass="math inline">\(bsum[i]-\)</span> <spanclass="math inline">\(bsum[j]+\)</span> <spanclass="math inline">\(c\)</span>，移项，得到：<spanclass="math inline">\(f[j]+\)</span> <spanclass="math inline">\(asum[j]^2-\)</span> <spanclass="math inline">\(bsum[j]=\)</span> <spanclass="math inline">\(2asum[i]sum[j]+\)</span> <spanclass="math inline">\(f[i]-\)</span> <spanclass="math inline">\(asum[i]^2-\)</span> <spanclass="math inline">\(bsum[i]-\)</span> <spanclass="math inline">\(c\)</span>，可用斜率优化，套用斜率优化模板即可，需要注意<span class="math inline">\(sum[j]\)</span> 的系数 <spanclass="math inline">\(2asum[i]&lt;0\)</span>，斜率是单调递减的，所以凸壳斜率的单调性与此前相反。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,a,b,c,s[<span class="number">1000005</span>],f[<span class="number">1000005</span>],q[<span class="number">1000005</span>];</span><br><span class="line"><span class="function">ll <span class="title">y</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> f[x]+a*s[x]*s[x]-b*s[x];&#125;</span><br><span class="line"><span class="function">ll <span class="title">k</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">2</span>*a*s[x];&#125;</span><br><span class="line"><span class="function">ll <span class="title">d</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> a*x*x+b*x+c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),<span class="built_in">wt</span>(-x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),a=<span class="built_in">rd</span>(),b=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]=<span class="built_in">rd</span>(),s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">y</span>(q[l+<span class="number">1</span>])-<span class="built_in">y</span>(q[l])&gt;=(s[q[l+<span class="number">1</span>]]-s[q[l]])*<span class="built_in">k</span>(i)) l++;</span><br><span class="line">        f[i]=f[q[l]]+<span class="built_in">d</span>(s[i]-s[q[l]]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;(<span class="built_in">y</span>(q[r])-<span class="built_in">y</span>(q[r<span class="number">-1</span>]))*(s[i]-s[q[r]])&lt;=(<span class="built_in">y</span>(i)-<span class="built_in">y</span>(q[r]))*(s[q[r]]-s[q[r<span class="number">-1</span>]])) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wt</span>(f[n]),<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P2900">洛谷P2900 LandAcquisition G</a></h3><p><span class="math inline">\(O(n)\)</span> 做法：设 <spanclass="math inline">\(f[i]\)</span> 表示前 <spanclass="math inline">\(i\)</span>块地被分为若干组，列出状态转移方程：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(min_{0\leq j&lt;i}(f[j]+\)</span> <spanclass="math inline">\(max_{j&lt;k\leq i}w[k]\times\)</span> <spanclass="math inline">\(max_{j&lt;k\leq i}l[k])\)</span>，发现在 <spanclass="math inline">\(min\)</span> 函数中还有 <spanclass="math inline">\(max\)</span>函数，不容易优化，考虑先对这些土地排序，以长度为第一关键字递增，宽度为第二关键字递减排序，排序过程中发现如果一块地的长度和宽度都比另一块地小，则它可以被包含于另一块地的费用中，之后不需要再考虑该块地，所以在排序过程中还需要将这种“可以被包含”的地块删去。最后剩下的地块类似于下图：</p><center><img src="https://img1.imgtp.com/2023/06/27/WAeimyga.png" alt="LandAcquisitionG1.png" title="LandAcquisitionG1.png" /></center><p>排序后，发现对于一个地块，如果排名在它前后的地块被分到了同一组，那么这一地块可以被分到该组而不产生贡献，如下图：</p><center><img src="https://img1.imgtp.com/2023/06/27/Cz3CY5By.png" alt="LandAcquisitionG2.png" title="LandAcquisitionG2.png" /></center><p>所以如果选中了两个不相邻的地块，把它们之间的地块也选入是更优解，从而最优的分组应该是若干连续段，得到新的状态转移方程：<spanclass="math inline">\(f[i]=\)</span> <spanclass="math inline">\(min_{0\leq j&lt;i}(f[j]+l[j+1]\times\)</span><span class="math inline">\(w[i])\)</span>，去掉 <spanclass="math inline">\(min\)</span> 函数，移项，得到：<spanclass="math inline">\(f[j]=\)</span> <spanclass="math inline">\(-w[i]l[j+1]+\)</span> <spanclass="math inline">\(f[i]\)</span>，这里需要注意新的分组是从 <spanclass="math inline">\(j+1\)</span> 到 <spanclass="math inline">\(i\)</span>的。之后套用斜率优化即可。这里排序的时间复杂度是 <spanclass="math inline">\(O(\log n)\)</span> 的，去重是 <spanclass="math inline">\(O(n)\)</span> 的，DP 是 <spanclass="math inline">\(O(n)\)</span> 的，总复杂度近似为 <spanclass="math inline">\(O(n)\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,f[<span class="number">50005</span>],q[<span class="number">50005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll W,L;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> W==x.W?L&gt;x.L:W&lt;x.W;&#125;</span><br><span class="line">&#125;land[<span class="number">50005</span>];</span><br><span class="line">ll w[<span class="number">50005</span>],l[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++) land[i].W=<span class="built_in">rd</span>(),land[i].L=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="built_in">sort</span>(land+<span class="number">1</span>,land+n+<span class="number">1</span>);</span><br><span class="line">    ll h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;land[q[t]].L&lt;=land[i].L) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=t;i++) w[i]=land[q[i]].W,l[i]=land[q[i]].L;</span><br><span class="line">    n=t,h=<span class="number">1</span>,t=<span class="number">1</span>,q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;f[q[h+<span class="number">1</span>]]-f[q[h]]&lt;=(l[q[h]+<span class="number">1</span>]-l[q[h+<span class="number">1</span>]+<span class="number">1</span>])*w[i]) h++;</span><br><span class="line">        f[i]=f[q[h]]+l[q[h]+<span class="number">1</span>]*w[i];</span><br><span class="line">        <span class="keyword">while</span>(h&lt;t&amp;&amp;(f[q[t]]-f[q[t<span class="number">-1</span>]])*(l[q[t]+<span class="number">1</span>]-l[i+<span class="number">1</span>])&gt;=(l[q[t<span class="number">-1</span>]+<span class="number">1</span>]-l[q[t]+<span class="number">1</span>])*(f[i]-f[q[t]])) t--;</span><br><span class="line">        q[++t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P4360">洛谷P4360锯木厂选址</a></h3><p><span class="math inline">\(O(n)\)</span>做法：修建两个锯木厂，将山坡划分为了三段，锯木厂直接修建在某棵树所在的位置显然比修建在该棵树与下一棵之间更优，设<span class="math inline">\(d[i]\)</span> 表示在第 <spanclass="math inline">\(i\)</span> 棵树所在地修建锯木厂省下的距离，即第<span class="math inline">\(i\)</span> 棵树到山脚的距离，<spanclass="math inline">\(w[i]\)</span> 表示在前 <spanclass="math inline">\(i\)</span> 棵树的重量和，则在第 <spanclass="math inline">\(i\)</span> 棵树所在地建锯木厂可省下花费 <spanclass="math inline">\(d[i]\timesw[i]\)</span>，于是得到第一个（距离山顶最近）的锯木厂修在 <spanclass="math inline">\(i\)</span>，第二个锯木厂修建在 <spanclass="math inline">\(j\)</span> 的最小花费为 <spanclass="math inline">\(ans=min(sum-\)</span> <spanclass="math inline">\(d[j]w[j]-\)</span> <spanclass="math inline">\(d[i](w[i] -\)</span> <spanclass="math inline">\(w[j]))\)</span>。去掉 <spanclass="math inline">\(min\)</span> 函数，移项，得到：<spanclass="math inline">\(d[j]w[j]=\)</span> <span class="math inline">\(-d[i ]w[ j ]+\)</span> <span class="math inline">\(sum-\)</span> <spanclass="math inline">\(ans-\)</span> <spanclass="math inline">\(d[i]w[i]\)</span>，套用斜率优化。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,sum,ans,l,r,w[<span class="number">20005</span>],d[<span class="number">20005</span>],q[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        w[i]=<span class="built_in">rd</span>(),d[i]=<span class="built_in">rd</span>(),w[i]+=w[i<span class="number">-1</span>],sum+=w[i]*d[i];</span><br><span class="line">    <span class="keyword">for</span>(ll i=n;i;i--) d[i]+=d[i+<span class="number">1</span>];</span><br><span class="line">    ans=<span class="number">0x3f3f3f3f</span>,l=<span class="number">1</span>,r=<span class="number">1</span>,q[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;d[q[l]]*w[q[l]]-d[q[l+<span class="number">1</span>]]*w[q[l+<span class="number">1</span>]]&lt;=(w[q[l]]-w[q[l+<span class="number">1</span>]])*d[i]) l++;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,sum-d[q[l]]*w[q[l]]-d[i]*(w[i]-w[q[l]]));</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;(d[q[r<span class="number">-1</span>]]*w[q[r<span class="number">-1</span>]]-d[q[r]]*w[q[r]])*(w[q[r]]-w[i])&lt;=(w[q[r<span class="number">-1</span>]]-w[q[r]])*(d[q[r]]*w[q[r]]-d[i]*w[i])) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> DP优化 </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列优化 DP</title>
      <link href="/2023/06/14/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/"/>
      <url>/2023/06/14/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列优化-dp">单调队列优化 DP</h1><p>前置知识：<ahref="https://intconstlee.github.io/posts/monotonic-queue/">单调队列</a></p><h2 id="一概览">一，概览</h2><p>某些特定DP，其当前状态的所有值都可以通过上一状态的某个连续段得到，要对这个连续段求区间最值，相邻状态的区间上下界单调变化。</p><p>对于这类动态规划问题，发现我们可以在状态转移当中引入单调队列，对 DP进行优化。</p><h2 id="二思路">二，思路</h2><details class="note" open><summary>例题：最大子序和</summary><p><p>给定一个长度为 <span class="math inline">\(N\)</span>的整数序列，从中找出一段长度不超过 <spanclass="math inline">\(M\)</span>的连续子序列，使得子序列中所有数的和最大。<spanclass="math inline">\(N,M\leq 3\times 10^5\)</span>。</p><p>对于这道题，其答案可以形式化表示为：</p><p><span class="math inline">\(ans=\)</span> <spanclass="math inline">\(max_{1\leq i\leq N}\)</span> <spanclass="math inline">\((sum[i]-\)</span> <spanclass="math inline">\(min_{i-M\leq j\leq i-1}\)</span> <spanclass="math inline">\(sum[j])\)</span></p><p>其中，<span class="math inline">\(i\)</span>类似于动态规划中的状态，<span class="math inline">\(j\)</span>类似于动态规划中的决策。我们从小到大枚举每个 <spanclass="math inline">\(i\in[1,N]\)</span> 时，当 <spanclass="math inline">\(i\)</span> 增大 <spanclass="math inline">\(1\)</span> 时，<spanclass="math inline">\(j\)</span> 的取值范围 <spanclass="math inline">\([i-M,i-1]\)</span> 的上下界也同时增大 <spanclass="math inline">\(1\)</span>，变为 <spanclass="math inline">\([i-M+1,i]\)</span>。这意味着有一个新的决策 <spanclass="math inline">\(j=i\)</span> 进入候选集和，同时 <spanclass="math inline">\(j=i-M\)</span>这一决策过时，需要从集合中删除。</p></p></details><p>经过分析发现此题取值范围上下界单调变化，每个决策在候选集和中最多被插入或删除一次，所求的是最值，可以使用单调队列优化。</p><p>首先求出每个元素的前缀和，建立前缀和数组。由于要求的是区间前缀和最小值，建立一个单调递增队列，以使队头为最小值，并保证了队头弹出后新队头为新的最小值。对于前缀和数组中的的每个数按一定规则依次插入，假设待插入元素下标为<span class="math inline">\(i\)</span>，值为 <spanclass="math inline">\(s[i]\)</span>，则插入规则可表示如下：</p><ol type="1"><li>若队头元素的下标 <span class="math inline">\(j\)</span> 满足 <spanclass="math inline">\(j&lt;i-M\)</span>，弹出队头；</li><li>查询最优决策时队头即为所求；</li><li>当队尾元素的值 <span class="math inline">\(s[j]\)</span> 足 <spanclass="math inline">\(s[j]&gt;s[i]\)</span>时，弹出队尾直到队列为空或满足单调性；</li><li>插入新元素的下标。</li></ol><p>对于第二条规则，由于 <span class="math inline">\(j\)</span>的取值最多到 <span class="math inline">\(i-1\)</span>，故让 <spanclass="math inline">\(i\)</span>先入队再查询是不正确的，而应该先查询。</p><p>对于第三条规则，<span class="math inline">\(s[j]&gt;s[i]\)</span>时，维护队列单调性。分析发现对于 <span class="math inline">\(i\)</span>之后的状态，取区间最小值时在 <span class="math inline">\(i\)</span> 和<span class="math inline">\(j\)</span> 中选择 <spanclass="math inline">\(i\)</span> 更优，<spanclass="math inline">\(j\)</span> 不会再有贡献，所以将队尾 <spanclass="math inline">\(j\)</span> 弹出直到队列单调是正确的。</p><p>对于第四条规则，在单调队列中仅需要插入下标即可，根据下标访问前缀和数组可得取值。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,ans,a[<span class="number">300005</span>];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i],a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">0</span>),ans=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;i-m) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,a[i]-a[q.<span class="built_in">front</span>()]);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;a[q.<span class="built_in">back</span>()]&gt;=a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="三单调队列优化多重背包">三，单调队列优化多重背包</h2><p>给出问题模型：</p><p>给定 <span class="math inline">\(N\)</span> 种物品，其中第 <spanclass="math inline">\(i\)</span> 种物品体积为 <spanclass="math inline">\(V_i\)</span>，价值为 <spanclass="math inline">\(W_i\)</span>，数量为 <spanclass="math inline">\(C_i\)</span>。有一个容积为 <spanclass="math inline">\(M\)</span>的背包，要求选择若干物品放入背包，使得物品总体积不超过 <spanclass="math inline">\(M\)</span> 的前提下价值之和最大</p><h3 id="回顾多重背包的解法">1. 回顾：多重背包的解法</h3><h4 id="朴素解法">① 朴素解法</h4><p>把第 <span class="math inline">\(i\)</span> 种物品看作独立的 <spanclass="math inline">\(C_i\)</span> 件物品，转化为 <spanclass="math inline">\(\sum_{i=1}^N C_i\)</span> 个物品的 <spanclass="math inline">\(0/1\)</span> 背包。时间复杂度为 <spanclass="math inline">\(O(M\times \sum_{i=1}^N C_i)\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[maxn+<span class="number">5</span>],v[maxn+<span class="number">5</span>],w[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> f[maxm+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0xc0</span>,<span class="built_in">sizeof</span>(f))   <span class="comment">//-inf</span></span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i];j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=m;k&gt;=v[i];k--)</span><br><span class="line">            f[k]=<span class="built_in">max</span>(f[k],f[k-v[i]]+w[i]);</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br></pre></td></tr></table></figure></details><h4 id="二进制拆分法">② 二进制拆分法</h4><p>在 <span class="math inline">\(2\)</span>的整数次幂中选取若干数相加，可以表示出任意整数，于是对于 <spanclass="math inline">\(C_i\)</span>，将其二进制拆分为 <spanclass="math inline">\(2^0+\)</span> <spanclass="math inline">\(2^1+\)</span> <spanclass="math inline">\(2^2+...+\)</span> <spanclass="math inline">\(2^p+R_i\)</span>，<spanclass="math inline">\(R_i&lt;2^{p+1}\)</span>，这样便将 <spanclass="math inline">\(C_i\)</span> 拆分为了 <spanclass="math inline">\(p+2\)</span>件物品，其体积与价值分别乘相应倍数后进行 <spanclass="math inline">\(0/1\)</span> 背包即可，时间复杂度为 <spanclass="math inline">\(O(M\times \sum_{i=1}^N \log C_i)\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c[maxn+<span class="number">5</span>],v[maxn+<span class="number">5</span>],w[maxn+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> t,val[maxN+<span class="number">5</span>],wei[maxN+<span class="number">5</span>]</span><br><span class="line"><span class="type">int</span> f[maxm+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0xc0</span>,<span class="built_in">sizeof</span>(f))   <span class="comment">//-inf</span></span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i];j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        wei[++t]=v[i]*j,val[t]=w[i]*j,c[i]-=j;</span><br><span class="line">    <span class="keyword">if</span>(c[i]) wei[++t]=v[i]*c[i],val[t]=w[i]*c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=wei[i];j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-wei[i]]+val[i]);</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br></pre></td></tr></table></figure></details><h3 id="单调队列优化">2. 单调队列优化</h3><p>若使用单调队列，时间复杂度可进一步降至 <spanclass="math inline">\(O(NM)\)</span>。</p><p>当外层循环进行到 <span class="math inline">\(i\)</span> 时，<spanclass="math inline">\(F[j]\)</span> 表示从前 <spanclass="math inline">\(i\)</span> 种物品中选若干放入背包使体积之和为<span class="math inline">\(j\)</span> 时，价值之和最大是多少。倒序循环<span class="math inline">\(j\)</span>，在状态转移时，第 <spanclass="math inline">\(i\)</span> 种物品个数为 <spanclass="math inline">\(cnt\)</span>，列出状态转移方程：</p><p><span class="math inline">\(F[j]=\)</span> <spanclass="math inline">\(max_{1\leq cnt\leq C_i}\)</span> <spanclass="math inline">\((F[j-cnt\times V_i]+\)</span> <spanclass="math inline">\(cnt\times\)</span> <spanclass="math inline">\(W_i)\)</span></p><p>能够转移到 <span class="math inline">\(j\)</span> 的候选集合为 <spanclass="math inline">\(\{j-cnt\times V_i|1\leq cnt\leqC_i\}\)</span>。发现相邻状态 <span class="math inline">\(j\)</span> 和<span class="math inline">\(j-1\)</span> 对应的候选集和没有重叠，很难由<span class="math inline">\(j-1\)</span> 对应的集合得到 <spanclass="math inline">\(j\)</span> 对应的集合。但是对于 <spanclass="math inline">\(j\)</span> 和 <spanclass="math inline">\(j-V_i\)</span>，这两者对应的候选集和重合度较高，由<span class="math inline">\(j-V_i\)</span> 向 <spanclass="math inline">\(j\)</span>转移时，一个已有决策被排除，只有一个新决策加入候选集和，所以我们可以把状态<span class="math inline">\(j\)</span> 按除以 <spanclass="math inline">\(V_i\)</span>的余数分组，对每一组分别计算，不同组之间不会互相转移。</p><p>新的 DP 过程如下：</p><p>对于每个余数 <span class="math inline">\(u\in[0,V_i-1]\)</span>，倒序循环 <span class="math inline">\(p\in[1,\lfloor(M-u)/V_i\rfloor]\)</span>，则对应的状态 <spanclass="math inline">\(j\)</span> 可表示为 <spanclass="math inline">\(j=u+p\times V_i\)</span>。第 <spanclass="math inline">\(i\)</span> 种物品有 <spanclass="math inline">\(C-i\)</span> 个。故能转移到 <spanclass="math inline">\(j=u+p\times V_i\)</span> 的候选集和就是 <spanclass="math inline">\(\{u+k\times V_i|p-C_i\leq k\leqp-1\}\)</span>。写出新的状态转移方程：</p><p><span class="math inline">\(F[u+p\times V_i]=\)</span> <spanclass="math inline">\(max_{p-C_i\leq k\leq p-1}\)</span> <spanclass="math inline">\((F[u+k\times V_i]+\)</span> <spanclass="math inline">\((p-k)\times\)</span> <spanclass="math inline">\(W_i)\)</span></p><p>把外层条件 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(u\)</span> 看作定值，内层循环 <spanclass="math inline">\(p\)</span> 减小 <spanclass="math inline">\(1\)</span> 时，决策 <spanclass="math inline">\(k\)</span> 的取值范围 <spanclass="math inline">\([p-C_i,p-1]\)</span>的上下界均单调减小。状态转移方程等号右侧的式子仍然可以分为两部分，仅包含变量<span class="math inline">\(p\)</span> 的 <spanclass="math inline">\(p\times W_i\)</span> 和仅包含变量 <spanclass="math inline">\(k\)</span> 的 <spanclass="math inline">\(F[u+k\times V_i]-k\timesW_i\)</span>。于是可以建立一个 <span class="math inline">\(k\)</span>单调递减，<span class="math inline">\(F[u+k\times V_i]-k\timesW_i\)</span> 也单调递减的队列维护候选集和，对于每个 <spanclass="math inline">\(p\)</span>，执行单调队列有以下三个操作：</p><ol type="1"><li>检查队头合法性，把大于 <span class="math inline">\(p-1\)</span>的决策出队。</li><li>取队头为最优策略</li><li>检查队尾单调性，弹出无用决策。</li><li>把决策 <span class="math inline">\(k=p-C_i-1\)</span> 入队。</li></ol><details class="note" close><summary>code：双端队列版（不推荐）</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[u+k*V[i]]-k*W[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x80</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;V[i];u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> maxn=(m-u)/V[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=maxn<span class="number">-1</span>;k&gt;=<span class="built_in">max</span>(maxn-C[i],<span class="number">0</span>);k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;<span class="built_in">calc</span>(i,u,q.<span class="built_in">back</span>())&lt;=<span class="built_in">calc</span>(i,u,k))</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=maxn;p&gt;=<span class="number">0</span>;p--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&gt;p<span class="number">-1</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">                <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">                    f[u+p*V[i]]=<span class="built_in">max</span>(f[u+p*V[i]],<span class="built_in">calc</span>(i,u,q.<span class="built_in">front</span>())+p*W[i]);</span><br><span class="line">                <span class="keyword">if</span>(p-C[i]<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;<span class="built_in">calc</span>(i,u,q.<span class="built_in">back</span>())&lt;=<span class="built_in">calc</span>(i,u,p-C[i]<span class="number">-1</span>))</span><br><span class="line">                        q.<span class="built_in">pop_back</span>();</span><br><span class="line">                    q.<span class="built_in">push_back</span>(p-C[i]<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details class="note" close><summary>code：数组版</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,v,w,c,mx,ans,f[<span class="number">40005</span>];</span><br><span class="line"><span class="type">int</span> h,t,q[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;w;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            h=<span class="number">1</span>,t=<span class="number">0</span>,mx=(m-u)/w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=mx<span class="number">-1</span>;k&gt;=<span class="built_in">max</span>(mx-c,<span class="number">0</span>);k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[u+q[t]*w]&lt;=f[u+k*w]+(q[t]-k)*v) t--;</span><br><span class="line">                q[++t]=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=mx;p&gt;=<span class="number">0</span>;p--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[h]&gt;p<span class="number">-1</span>) h++;</span><br><span class="line">                <span class="keyword">if</span>(h&lt;=t) f[u+p*w]=<span class="built_in">max</span>(f[u+p*w],f[u+q[h]*w]+(p-q[h])*v);</span><br><span class="line">                <span class="keyword">if</span>(p-c<span class="number">-1</span>&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[u+q[t]*w]&lt;=f[u+(p-c<span class="number">-1</span>)*w]+(q[t]-(p-c<span class="number">-1</span>))*v) t--;</span><br><span class="line">                q[++t]=p-c<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">wt</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="四总结">四，总结</h2><p>对于可以使用单调队列优化的题目，可以总结出如下通式：</p><p><span class="math inline">\(F[i]=\)</span> <spanclass="math inline">\(min_{L(i)\leq j\leq R(i)}\)</span> <spanclass="math inline">\((F[j]+\)</span> <spanclass="math inline">\(val(i,j))\)</span></p><p>其中 <span class="math inline">\(val(i,j)\)</span>可分为两部分，一部分仅与 <span class="math inline">\(i\)</span>有关，另一部分仅与 <span class="math inline">\(j\)</span> 有关。</p><p>对于每个 <span class="math inline">\(i\)</span>，无论采取哪个 <spanclass="math inline">\(j\)</span> 作为决策，与 <spanclass="math inline">\(i\)</span> 有关的部分都是相等的，而当 <spanclass="math inline">\(i\)</span> 变化时，与 <spanclass="math inline">\(j\)</span>有关的部分不会发生变化，从而原来较优的决策在 <spanclass="math inline">\(i\)</span> 改变后仍较优。</p><p>于是我们就可以使用单调队列维护第二部分单调性。</p><p>至于这一通式，在之后的学习中还会遇到。</p><h2 id="五习题">五，习题</h2><h3><a href="https://www.luogu.com.cn/problem/P1776">洛谷P1776 宝物筛选</a></h3><p>套用多重背包板子即可。推荐使用二进制拆分（好写）或数组队列（较快）。</p><details class="note" close><summary>code：双端队列</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,ans,v[<span class="number">100005</span>],w[<span class="number">100005</span>],c[<span class="number">100005</span>],f[<span class="number">40005</span>];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[u+k*w[i]]-k*v[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i]=<span class="built_in">rd</span>(),w[i]=<span class="built_in">rd</span>(),c[i]=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">if</span>(w[i]==<span class="number">0</span>) &#123;ans+=w[i]*c[i];<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;w[i];u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mx=(m-u)/w[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=mx<span class="number">-1</span>;k&gt;=<span class="built_in">max</span>(mx-c[i],<span class="number">0</span>);k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;<span class="built_in">calc</span>(i,u,q.<span class="built_in">back</span>())&lt;=<span class="built_in">calc</span>(i,u,k))</span><br><span class="line">                    q.<span class="built_in">pop_back</span>();</span><br><span class="line">                q.<span class="built_in">push_back</span>(k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=mx;p&gt;=<span class="number">0</span>;p--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&gt;p<span class="number">-1</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">                <span class="keyword">if</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">                    f[u+p*w[i]]=<span class="built_in">max</span>(f[u+p*w[i]],<span class="built_in">calc</span>(i,u,q.<span class="built_in">front</span>())+p*v[i]);</span><br><span class="line">                <span class="keyword">if</span>(p-c[i]<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;<span class="built_in">calc</span>(i,u,q.<span class="built_in">back</span>())&lt;=<span class="built_in">calc</span>(i,u,p-c[i]<span class="number">-1</span>))</span><br><span class="line">                        q.<span class="built_in">pop_back</span>();</span><br><span class="line">                    q.<span class="built_in">push_back</span>(p-c[i]<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">wt</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details class="note" close><summary>code：数组队列</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,v,w,c,mx,ans,f[<span class="number">40005</span>];</span><br><span class="line"><span class="type">int</span> h,t,q[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>(),c=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>;u&lt;w;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            h=<span class="number">1</span>,t=<span class="number">0</span>,mx=(m-u)/w;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=mx<span class="number">-1</span>;k&gt;=<span class="built_in">max</span>(mx-c,<span class="number">0</span>);k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[u+q[t]*w]&lt;=f[u+k*w]+(q[t]-k)*v) t--;</span><br><span class="line">                q[++t]=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=mx;p&gt;=<span class="number">0</span>;p--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[h]&gt;p<span class="number">-1</span>) h++;</span><br><span class="line">                <span class="keyword">if</span>(h&lt;=t) f[u+p*w]=<span class="built_in">max</span>(f[u+p*w],f[u+q[h]*w]+(p-q[h])*v);</span><br><span class="line">                <span class="keyword">if</span>(p-c<span class="number">-1</span>&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[u+q[t]*w]&lt;=f[u+(p-c<span class="number">-1</span>)*w]+(q[t]-(p-c<span class="number">-1</span>))*v) t--;</span><br><span class="line">                q[++t]=p-c<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    <span class="built_in">wt</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details class="note" close><summary>code：二进制拆分</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,W,val,wei,num;</span><br><span class="line"><span class="type">int</span> v[<span class="number">2000000</span>],w[<span class="number">2000000</span>],f[<span class="number">2000000</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    N=<span class="built_in">rd</span>(),W=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        val=<span class="built_in">rd</span>(),wei=<span class="built_in">rd</span>(),num=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num;j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            v[++cnt]=val*j,w[cnt]=wei*j,num-=j;</span><br><span class="line">        <span class="keyword">if</span>(num)</span><br><span class="line">            v[++cnt]=val*num,w[cnt]=wei*num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+v[i]);</span><br><span class="line">    cout&lt;&lt;f[W];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P2254">洛谷P2254瑰丽华尔兹</a></h3><p><span class="math inline">\(O(NMK)\)</span> 做法：设 <spanclass="math inline">\(f[i][j][k]\)</span> 代表第 <spanclass="math inline">\(i\)</span> 个时间段结束时到达 <spanclass="math inline">\((j,k)\)</span>的最长滑行距离，初始为负无穷，起点为 <spanclass="math inline">\(0\)</span>。对于每一次询问，给出 <spanclass="math inline">\(s,t\)</span>之后可以得到最大滑行长度，之后按方向遍历每一行（列），运用单调队列滑动窗口优化，可以在<span class="math inline">\(O(NM)\)</span> 时间复杂度得到一次移动后的 DP数组，总共 <span class="math inline">\(K\)</span> 次询问，总复杂度 <spanclass="math inline">\(O(NMK)\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> D[<span class="number">2</span>][<span class="number">6</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> mp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="type">int</span> n,m,x,y,k,s,t,d,mx,ans,f[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">que</span> &#123;<span class="type">int</span> dp,len;&#125; q[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> mx,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>,l=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m;x+=D[<span class="number">0</span>][d],y+=D[<span class="number">1</span>][d],l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[x][y]==<span class="string">&#x27;x&#x27;</span>) &#123;h=<span class="number">1</span>,t=<span class="number">0</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[t].dp+l-q[t].len&lt;f[x][y]) t--;</span><br><span class="line">        q[++t]=&#123;f[x][y],l&#125;;</span><br><span class="line">        <span class="keyword">if</span>(h&lt;=t&amp;&amp;q[t].len-q[h].len&gt;mx) h++;</span><br><span class="line">        f[x][y]=q[h].dp+l-q[h].len,ans=<span class="built_in">max</span>(ans,f[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),x=<span class="built_in">rd</span>()<span class="number">-1</span>,y=<span class="built_in">rd</span>()<span class="number">-1</span>,k=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f)),f[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="built_in">rd</span>(),t=<span class="built_in">rd</span>(),d=<span class="built_in">rd</span>(),mx=t-s+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">1</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="built_in">solve</span>(n<span class="number">-1</span>,j,mx,d);</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">2</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) <span class="built_in">solve</span>(<span class="number">0</span>,j,mx,d);</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">3</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="built_in">solve</span>(j,m<span class="number">-1</span>,mx,d);</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">4</span>) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) <span class="built_in">solve</span>(j,<span class="number">0</span>,mx,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wt</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P2569">洛谷P2569 股票交易</a></h3><p><span class="math inline">\(O(T·MaxP)\)</span> 做法：设 <spanclass="math inline">\(f[i][j]\)</span> 代表第 <spanclass="math inline">\(i\)</span> 天结束时持有 <spanclass="math inline">\(j\)</span> 股时收益最大值，第 <spanclass="math inline">\(0\)</span> 天初始负无穷，<spanclass="math inline">\(f[0][0]=0\)</span>。之后考虑转移，对于每一天有如下三种情况：1. 可以不进行交易，此时 <spanclass="math inline">\(f[i][j]=f[i-1][j]\)</span>； 2. 可以买入，此时第<span class="math inline">\(i\)</span> 天的结果将由第 <spanclass="math inline">\(\max(i-w-1,0)\)</span> 天转移得到，以 <spanclass="math inline">\(as\)</span>为滑动窗口大小，引入单调队列优化进行转移。 3. 可以卖出，同样由第 <spanclass="math inline">\(\max(i-w-1,0)\)</span> 天转移得到，以 <spanclass="math inline">\(bs\)</span> 为窗口大小单调队列优化。</p><p>需要注意，买入时持有 <span class="math inline">\(j\)</span>股的状态只能由比 <span class="math inline">\(j\)</span>小的状态得到，所以正序枚举 <spanclass="math inline">\(j\)</span>，类似的，卖出时持有 <spanclass="math inline">\(j\)</span> 股的状态只能由比 <spanclass="math inline">\(j\)</span> 大的状态得到，所以倒序枚举 <spanclass="math inline">\(j\)</span>。</p><p>显然转移到最后一天时，若手中有股票，全部卖出会得到更优解，于是答案取<span class="math inline">\(f[T][0]\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,w,ap,bp,as,bs,lst,h,t,f[<span class="number">2005</span>][<span class="number">2005</span>],q[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),m=<span class="built_in">rd</span>(),w=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[<span class="number">0</span>][i]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ap=<span class="built_in">rd</span>(),bp=<span class="built_in">rd</span>(),as=<span class="built_in">rd</span>(),bs=<span class="built_in">rd</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++) f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        lst=<span class="built_in">max</span>(i-w<span class="number">-1</span>,<span class="number">0</span>),h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[h]&lt;j-as) h++;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[lst][q[t]]+(q[t]-j)*ap&lt;f[lst][j]) t--;</span><br><span class="line">            q[++t]=j,f[i][j]=<span class="built_in">max</span>(f[i][j],f[lst][q[h]]+(q[h]-j)*ap);</span><br><span class="line">        &#125;</span><br><span class="line">        h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[h]&gt;j+bs) h++;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;=t&amp;&amp;f[lst][q[t]]+(q[t]-j)*bp&lt;f[lst][j]) t--;</span><br><span class="line">            q[++t]=j,f[i][j]=<span class="built_in">max</span>(f[i][j],f[lst][q[h]]+(q[h]-j)*bp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P3572">洛谷P3572 PTA-LittleBird</a></h3><p><span class="math inline">\(O(qn)\)</span> 做法：设 <spanclass="math inline">\(f[i]\)</span> 代表一只鸟飞到第 <spanclass="math inline">\(i\)</span> 棵树的最小疲劳值，初始为正无穷，<spanclass="math inline">\(f[1]=0\)</span>。<spanclass="math inline">\(f[i]\)</span> 可以由 <spanclass="math inline">\(f[i-k]\)</span> 到 <spanclass="math inline">\(f[i-1]\)</span> 转移而来，于是引入单调队列优化DP。建立一个单调递增队列维护，队头为疲劳值最小值，但注意到转移还与树的高度有关，应是队头元素的高度最大以使转移中尽量不增加疲劳值。由于转移中疲劳值至多增加一，故取疲劳值低的转移一定不劣于取疲劳值高的转移，故单调队列应以疲劳值为第一关键字单调递减，相同疲劳值以树高为第二关键字比较，在队列中保留树高较高的即可。答案取<span class="math inline">\(f[n]\)</span>。</p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k,h,t,d[<span class="number">1000005</span>],f[<span class="number">1000005</span>],q[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i]=<span class="built_in">rd</span>();</span><br><span class="line">    m=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k=<span class="built_in">rd</span>(),h=<span class="number">1</span>,t=<span class="number">1</span>,q[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f)),f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(h&lt;=t&amp;&amp;q[h]&lt;j-k) h++;</span><br><span class="line">            f[j]=f[q[h]]+(d[q[h]]&lt;=d[j]);</span><br><span class="line">            <span class="keyword">while</span>(h&lt;=t&amp;&amp;(f[q[t]]==f[j]?d[j]&gt;d[q[t]]:f[j]&lt;f[q[t]])) t--;</span><br><span class="line">            q[++t]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wt</span>(f[n]),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3><a href="https://www.luogu.com.cn/problem/P3594">洛谷P3594 WIL</a></h3><p><span class="math inline">\(O(n)\)</span>做法：题意就是找一段大区间，其中间一段不长于 <spanclass="math inline">\(d\)</span> 的小区间内所有数变 <spanclass="math inline">\(0\)</span> 后大区间内所有数的和不大于 <spanclass="math inline">\(p\)</span>，求大区间最长长度。首先有一个显然结论就是变<span class="math inline">\(0\)</span>的点越多，答案越优，也就是说必然有 <spanclass="math inline">\(d\)</span> 个点变 <spanclass="math inline">\(0\)</span>。此外还有大区间某端点一定时，变 <spanclass="math inline">\(0\)</span>的小区间原值和越大，答案越优，因为删去的值增大，大区间的另一端点只可能更远离定端点，此时大区间只可能更大。</p><p>接下来考虑 DP，从 <span class="math inline">\(d\)</span>开始枚举大区间右端点 <spanclass="math inline">\(i\)</span>，大区间左端点初始为 <spanclass="math inline">\(1\)</span>，引入单调递减队列维护变 <spanclass="math inline">\(0\)</span>区间的原值和最大值，队列中存小区间左端点。</p><p>首先在保证单调性前提下将以 <span class="math inline">\(i\)</span>为右端点的小区间的左端点入队。之后比较大区间删去 <spanclass="math inline">\(sum[q[h]+d-1]-\)</span> <spanclass="math inline">\(sum[q[h]-1]\)</span> 后的数值和与 <spanclass="math inline">\(p\)</span> 的关系，若大于 <spanclass="math inline">\(p\)</span>，则大区间左端点 <spanclass="math inline">\(l\)</span> 需右移，注意右移 <spanclass="math inline">\(l\)</span>时还要检查小区间是否包含在大区间内，若不在，更新小区间。</p><p>最终答案即为 <spanclass="math inline">\(\max_{r=d}^n(r-l+1)\)</span></p><details class="note" close><summary>code</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,p,d,h,t,l,ans,w[<span class="number">2000005</span>],q[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),p=<span class="built_in">rd</span>(),d=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) w[i]=<span class="built_in">rd</span>(),w[i]+=w[i<span class="number">-1</span>];</span><br><span class="line">    ans=d,l=<span class="number">1</span>,h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=d;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;=t&amp;&amp;w[q[t]+d<span class="number">-1</span>]-w[q[t]<span class="number">-1</span>]&lt;=w[i]-w[i-d]) t--;</span><br><span class="line">        q[++t]=i-d+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i-l+<span class="number">1</span>&gt;d&amp;&amp;w[i]-w[l<span class="number">-1</span>]-w[q[h]+d<span class="number">-1</span>]+w[q[h]<span class="number">-1</span>]&gt;p)</span><br><span class="line">            &#123;l++;<span class="keyword">if</span>(h&lt;=t&amp;&amp;q[h]&lt;l) h++;&#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,i-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wt</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> DP优化 </tag>
            
            <tag> 单调队列优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="/2023/06/14/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2023/06/14/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列">单调队列</h1><h2 id="一概览">一，概览</h2><p>单调队列的重点在于<strong>单调</strong>和<strong>队列</strong></p><ol type="1"><li>单调反映了元素变化的规律是递增或递减；</li><li>队列意味着对元素的操作只能在队头和队尾进行。</li></ol><h2 id="二实现">二，实现</h2><p>建立一个队列，考虑要向里插入一个元素：</p><p>比较要插入的元素和现有的队尾，若满足所需的单调性，则直接插入队尾，若不满足单调性，则重复弹出队尾直到满足单调性或队列为空，之后将新元素插入队尾。</p><p>单调队列最经典的实现就是滑动窗口，即给出一个数组 <spanclass="math inline">\(a_{1,2,...,n}\)</span>，给出一个长度 <spanclass="math inline">\(k\)</span>，在数组中找到每一段长为 <spanclass="math inline">\(k\)</span> 的区间的区间最值。</p><div><details class="note" open><summary>模板题面</summary><p><p><a href=https://www.luogu.com.cn/problem/P1886>Luogu P1886滑动窗口/【模板】单调队列 </a></p><p>有一个长为 <span class="math inline">\(n\)</span> 的序列 <spanclass="math inline">\(a\)</span>，以及一个大小为 <spanclass="math inline">\(k\)</span>的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p><p>输入一共有两行，第一行有两个正整数 <spanclass="math inline">\(n,k\)</span>。 第二行 <spanclass="math inline">\(n\)</span> 个整数，表示序列 <spanclass="math inline">\(a\)</span></p><p>输出共两行，第一行为每次窗口滑动的最小值<br />第二行为每次窗口滑动的最大值</p><p>样例输入 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><p>样例输出 #1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure><p>【数据范围】<br />对于 <span class="math inline">\(50\%\)</span> 的数据，<spanclass="math inline">\(1 \le n \le 10^5\)</span>；<br />对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(1\le k \le n \le 10^6\)</span>，<spanclass="math inline">\(a_i \in [-2^{31},2^{31})\)</span>。</p></p></details><details class="note" close><summary>deque 实现</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k,a[<span class="number">1000005</span>];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),<span class="built_in">wt</span>(-x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;i-k+<span class="number">1</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;a[q.<span class="built_in">back</span>()]&gt;=a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k) <span class="built_in">wt</span>(a[q.<span class="built_in">front</span>()]),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>),q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span>()&amp;&amp;q.<span class="built_in">front</span>()&lt;i-k+<span class="number">1</span>) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()&amp;&amp;a[q.<span class="built_in">back</span>()]&lt;=a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k) <span class="built_in">wt</span>(a[q.<span class="built_in">front</span>()]),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details class="note" close><summary>数组实现</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k,a[<span class="number">1000005</span>],q[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">wt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123;<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),<span class="built_in">wt</span>(-x);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) <span class="built_in">wt</span>(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">rd</span>(),k=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">rd</span>();</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=r&amp;&amp;q[l]&lt;i-k+<span class="number">1</span>) l++;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[r]]&gt;=a[i]) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k) <span class="built_in">wt</span>(a[q[l]]),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>),l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=r&amp;&amp;q[l]&lt;i-k+<span class="number">1</span>) l++;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[r]]&lt;=a[i]) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k) <span class="built_in">wt</span>(a[q[l]]),<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左偏树</title>
      <link href="/2023/06/10/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
      <url>/2023/06/10/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="左偏树">左偏树</h1><p>左偏树是可并堆的一种，具有堆的性质，可快速合并.</p><p>维护如下信息：<spanclass="math inline">\(\text{val}\)</span>：权值，<spanclass="math inline">\(\text{ls}\)</span>：左儿子，<spanclass="math inline">\(\text{rs}\)</span>：右儿子，<spanclass="math inline">\(\text{dist}\)</span>：距离，<spanclass="math inline">\(\text{fa}\)</span>：父亲。</p><h2 id="一dist">一，dist</h2><p>对于一棵二叉树，我们定义外结点为左儿子或右儿子为空的结点。</p><p>定义一个外结点的 <span class="math inline">\(\text{dist}\)</span> 为<span class="math inline">\(1\)</span>，非外结点的 <spanclass="math inline">\(\text{dist}\)</span>为其到子树中最近外结点的距离加一，空结点的 <spanclass="math inline">\(\text{dist}\)</span> 为 <spanclass="math inline">\(0\)</span>。</p><p>现在有一棵 <span class="math inline">\(n\)</span>个结点的二叉树，则有如下性质：</p><ol type="1"><li><p>根的 <span class="math inline">\(\text{dist}\)</span> 不超过<span class="math inline">\([log(n+1)]\)</span>；</p></li><li><p>若该二叉树根的 <span class="math inline">\(\text{dist}\)</span>为 <span class="math inline">\(x\)</span>，则至少有 <spanclass="math inline">\(x-1\)</span> 层为满二叉树，至少有 <spanclass="math inline">\(2^x-1\)</span> 个结点。</p></li></ol><h2 id="二左偏树的性质">二，左偏树的性质</h2><p>左偏树是一棵二叉树，它具有如下性质：</p><ol type="1"><li><p>堆的性质；</p></li><li><p>每个结点左儿子的 <span class="math inline">\(\text{dist}\)</span>大于等于右儿子的 <spanclass="math inline">\(\text{dist}\)</span>；</p></li><li><p>每个结点的 <span class="math inline">\(\text{dist}\)</span>都等于右儿子的 <spanclass="math inline">\(\text{dist}+1\)</span>。</p></li></ol><p>左偏树的深度无保证，一条向左的链也是左偏树。</p><h2 id="三核心操作合并-merge">三，核心操作——合并 merge</h2><ol type="1"><li><p>取值较小的根作为合并后堆的根节点；</p></li><li><p>将这个根的左儿子作为合并后堆的左儿子；</p></li><li><p>递归合并其右儿子和另一个堆，作为合并后堆的右儿子；</p></li><li><p>若合并后左儿子的 <span class="math inline">\(\text{dist}\)</span>小于右儿子的 <spanclass="math inline">\(\text{dist}\)</span>，交换两儿子。</p></li></ol><p>该操作的时间复杂度是 <span class="math inline">\(O(\log n+\logm)\)</span> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(val[x]&gt;val[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    rs[x]=<span class="built_in">merge</span>(rs[x],y),fa[rs[x]]=x;</span><br><span class="line">    <span class="keyword">if</span>(dis[ls[x]]&lt;dis[rs[x]]) <span class="built_in">swap</span>(ls[x],rs[x]);</span><br><span class="line">    dis[x]=dis[rs[x]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四其他操作">四，其他操作</h2><h3 id="插入结点">插入结点</h3><p>将单个结点视为一个堆，合并即可。</p><h3 id="删除根">删除根</h3><p>合并根的左右儿子。</p><h3 id="删除任意结点">删除任意结点</h3><p>合并左右儿子，自底向上更新 <spanclass="math inline">\(\text{dist}\)</span>，不满足左偏性质时交换左右儿子，<spanclass="math inline">\(\text{dist}\)</span> 无需更新时结束递归。</p><p>时间复杂度：<span class="math inline">\(O(\log n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(dis[ls[x]]&lt;dis[rs[x]]) <span class="built_in">swap</span>(ls[x],rs[x]);</span><br><span class="line">    <span class="keyword">if</span>(dis[x]!=dis[rs[x]]+<span class="number">1</span>)</span><br><span class="line">        dis[x]=dis[rs[x]]+<span class="number">1</span>,<span class="built_in">pushup</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对整个堆进行加减乘运算">对整个堆进行加/减/乘运算</h3><p>在根上打标记，删除根/合并堆时下传即可。</p>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 可并堆 </tag>
            
            <tag> 左偏树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机</title>
      <link href="/2023/06/08/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2023/06/08/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="ac-自动机">AC 自动机</h1><p>AC 自动机是以 Trie 树结构为基础，结合 KMP思想建立的自动机，用于解决多模式匹配等任务。</p><h2 id="一概览">一，概览</h2><p>用两步建立一个 AC 自动机：</p><ol type="1"><li>建立 Trie 树。（以 Trie 树为基础）</li><li>对 Trie 树上的所有结点构造失配指针。（结合 KMP 思想）</li></ol><p>之后便可以用它进行匹配了。</p><h2 id="二字典树构建">二，字典树构建</h2><p>AC 自动机所用的 Trie 就是普通的 Trie。</p><p>在 Trie 当中，结点表示某个模式串的前缀。Trie的结点表示状态，边表示转移。</p><p>对于若干模式串 <spanclass="math inline">\(s_1,s_2,...,s_n\)</span>，将它们构建成字典树后所有状态的集合记为<span class="math inline">\(Q\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt,tr[<span class="number">1000005</span>][<span class="number">26</span>],ended[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">        u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ended[u]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三失配指针">三，失配指针</h2><p>AC 自动机利用 fail 指针辅助完成匹配。 理解 fail 指针对理解 AC自动机意义重大。</p><h3 id="理解-fail-指针">1.理解 fail 指针</h3><p>fail 指针从一个状态 <span class="math inline">\(u\)</span>出发，指向一个状态 <span class="math inline">\(v\)</span>，Trie树中每个状态对应一个由根结点出发的字符串，状态 <spanclass="math inline">\(v\)</span> 所对应字符串是状态 <spanclass="math inline">\(u\)</span> 所对应字符串的最长后缀。</p><p>有图为证：</p><center><p><img src="https://img1.imgtp.com/2023/06/27/9MMIsXSy.png" alt="fail的构建1.png" title="fail的构建1.png" /></p><p><img src="https://img1.imgtp.com/2023/06/27/QPWJuRtY.png" alt="fail的构建2.png" title="fail的构建2.png" /></p></center><p>fail 指针可以从 Trie树上任意结点出发，其指向的结点可能为普通结点，也可能为模式串匹配结点，通过跳fail 可以使同一位上匹配多个模式串，详细的运作规律将在下文讲解。</p><center><p><img src="https://img1.imgtp.com/2023/06/27/VBzkqln7.png" alt="fail的构建3.png" title="fail的构建3.png" /></p></center><h3 id="实现-fail-指针">实现 fail 指针</h3><p>当前结点为 <span class="math inline">\(u\)</span>，其父结点为 <spanclass="math inline">\(p\)</span>，<span class="math inline">\(p\)</span>通过字符 <span class="math inline">\(c\)</span> 指向 <spanclass="math inline">\(u\)</span>，即 <spanclass="math inline">\(\delta(p,c)=u\)</span>，若深度小于 <spanclass="math inline">\(u\)</span> 的结点的 fail 指针均已知：</p><ol type="1"><li>如果 <span class="math inline">\(\delta(\text{fail}[p],c)\)</span>存在，即状态 <span class="math inline">\(p\)</span> 的最长后缀添加 <spanclass="math inline">\(c\)</span> 后依然合法，而 <spanclass="math inline">\(u\)</span> 是由状态 <spanclass="math inline">\(p\)</span> 添加 <spanclass="math inline">\(c\)</span> 得到的，此时状态 <spanclass="math inline">\(\delta(\text{fail}[p],c)\)</span> 是 <spanclass="math inline">\(u\)</span> 的最长后缀。</li><li>如果 <span class="math inline">\(\delta(\text{fail}[p],c)\)</span>不存在，则继续找 <span class="math inline">\(\text{fail}[p]\)</span> 的<span class="math inline">\(\text{fail}\)</span>指针，直到找到合法方案或跳至根结点。</li><li>若直到根结点也未找到合法方案，则 <spanclass="math inline">\(\text{fail}\)</span> 指向根结点。</li></ol><center><p><img src="https://img1.imgtp.com/2023/06/27/haqKStR7.png" alt="求fail1.png" title="求fail1.png" /></p><p><img src="https://img1.imgtp.com/2023/06/27/qZZXf7x1.png" alt="求fail2.png" title="求fail2.png" /></p></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fail[<span class="number">1000005</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">            <span class="comment">//这里修改了 Trie 的结构</span></span><br><span class="line">            <span class="comment">//保证了失配时可以转移到一个合法的状态以便继续匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四匹配的过程">四，匹配的过程</h2><p>匹配到每一位，不断跳 fail 并更新答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j&amp;&amp;ended[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            ret+=ended[j],ended[j]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五版">五，版</h2><div><details class=note close><summary>模板一</summary><p><p><a href=https://www.luogu.com.cn/problem/P3808>Luogu P3808【模板】AC自动机（简单版） </a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> trie[<span class="number">1000005</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> fail[<span class="number">1000005</span>],ended[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!trie[u][s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">            trie[u][s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">        u=trie[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    ended[u]++;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(trie[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(trie[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(trie[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                fail[trie[u][i]]=trie[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(trie[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> trie[u][i]=trie[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=trie[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j&amp;&amp;ended[j]!=<span class="number">-1</span>;j=fail[j])</span><br><span class="line">            ret+=ended[j],ended[j]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;s,<span class="built_in">insert</span>(s);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">query</span>(s);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div><details class=note close><summary>模板二</summary><p><p><a href=https://www.luogu.com.cn/problem/P3796>Luogu P3808【模板】AC自动机（加强版） </a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s[<span class="number">155</span>],t;</span><br><span class="line"><span class="type">int</span> tot,tr[<span class="number">12005</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">int</span> fail[<span class="number">12005</span>],id[<span class="number">12005</span>],val[<span class="number">12005</span>],cnt[<span class="number">12005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));</span><br><span class="line">    <span class="built_in">memset</span>(fail,<span class="number">0</span>,<span class="built_in">sizeof</span>(fail));</span><br><span class="line">    <span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="built_in">sizeof</span>(id));</span><br><span class="line">    <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="built_in">sizeof</span>(val));</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>]) tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>]=++tot;</span><br><span class="line">        u=tr[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    id[u]=m;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="number">0</span>,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=tr[u][t[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=u;j;j=fail[j]) val[j]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(id[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ret=<span class="built_in">max</span>(ret,val[i]);</span><br><span class="line">            cnt[id[i]]=val[i];</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]==ret)</span><br><span class="line">            cout&lt;&lt;s[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">restart</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;s[i];</span><br><span class="line">            <span class="built_in">insert</span>(s[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        <span class="built_in">query</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><div><details class=note close><summary>模板三</summary><p><p><a href=https://www.luogu.com.cn/problem/P5357>Luogu P3808【模板】AC自动机（二次加强版） </a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; H;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tot,tr[<span class="number">2000005</span>][<span class="number">26</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fail[<span class="number">2000005</span>],val[<span class="number">2000005</span>],id[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preH</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)</span><br><span class="line">        H[i]=(<span class="type">int</span>)i-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s,<span class="type">long</span> <span class="type">long</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> u=<span class="number">0</span>,siz=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;siz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!tr[u][H[s[i]]]) tr[u][H[s[i]]]=++tot;</span><br><span class="line">        u=tr[u][H[s[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    id[m]=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> tmp1,tmp2;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> q[<span class="number">2000005</span>],indg[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q[++tmp2]=tr[<span class="number">0</span>][i];</span><br><span class="line">    <span class="keyword">while</span>(tmp2-tmp1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> u=q[++tmp1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[u][i])</span><br><span class="line">            &#123;</span><br><span class="line">                fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">                indg[fail[tr[u][i]]]++;</span><br><span class="line">                q[++tmp2]=tr[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tmp1=tmp2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">        <span class="keyword">if</span>(indg[i]==<span class="number">0</span>) q[++tmp2]=i;</span><br><span class="line">    <span class="keyword">while</span>(tmp2-tmp1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> u=q[++tmp1],v=fail[u];</span><br><span class="line">        indg[v]--,val[v]+=val[u];</span><br><span class="line">        <span class="keyword">if</span>(indg[v]==<span class="number">0</span>) q[++tmp2]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> u=<span class="number">0</span>,siz=t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">0</span>;i&lt;siz;i++)</span><br><span class="line">        u=tr[u][H[t[i]]],val[u]++;</span><br><span class="line">    <span class="built_in">topu</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;val[id[i]]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">preH</span>();</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;s,<span class="built_in">insert</span>(s,i);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">query</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><p><span class="math inline">\(Finished.\)</span></p>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 自动机 </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动机概览</title>
      <link href="/2023/06/07/%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A6%82%E8%A7%88/"/>
      <url>/2023/06/07/%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h1 id="自动机">自动机</h1><p>自动机是一种对信号序列进行判定的数学模型</p><h2 id="一主观理解">一，主观理解</h2><p>以上为自动机的定义，该定义十分抽象，以下为笔者的主观理解。</p><h3 id="自动机建立的基础">1. 自动机建立的基础</h3><p>即定义中的“信号序列”。</p><p>我们可以把这个所谓“信号序列”理解为一个串，串的每一位上存有信息。</p><p>eg.字符串是一个“信号序列”，数组是一个“信号序列”，一个数的各位可以构成一个“信号序列”。</p><p>自动机便是建立在信号序列的基础上的。</p><h3 id="自动机要干什么">2. 自动机要干什么</h3><p>即定义中的“判定”。</p><p>对针对信号序列的特定命题给出真或假的回答。</p><p>eg.判断一个数是奇数还是偶数是判定，判断一个字符串是否回文是判定，判断一个字符串是否是一特定字符串的子串是判定。</p><h3 id="自动机的具象化理解">3. 自动机的具象化理解</h3><p>虽然自动机是一个抽象的数学模型，但在 OI里，自动机常可以被理解为一张有向图，我们把自动机所求的判定拆解为若干小判定，每一个结点都代表某次判定时的状态，结点向结点转移便是判定的过程，判定会有多种结果，因而一个结点的不同子结点便代表判定的不同结果。</p><p>以下图片有助于更好地理解：</p><div><center><p><img src="https://img1.imgtp.com/2023/06/27/OGbcGBME.png" alt="自动机的建立.png" title="自动机的建立.png" /></p><p><img src="https://img1.imgtp.com/2023/06/27/eqpZDSNR.png" alt="自动机的判定.png" title="自动机的判定.png" /></p><img src="https://img1.imgtp.com/2023/06/27/rXZNGWnF.png" alt="自动机的实现.png" title="自动机的实现.png" /></center></div><p>eg. 在 Trie 树上查找某字符串是否出现时，Trie树便可视为自动机的一个实现，它针对一些特定文本串建立（信号序列），并完成对某字符串是否出现的判断（判定）。</p><h2 id="二形式化理解">二，形式化理解</h2><p>一个有限状态自动机（DFA）由以下五部分构成：</p><ol type="1"><li>字符集（<spanclass="math inline">\(\Sigma\)</span>）：该自动机只能输入这些字符。</li><li>状态集合（<spanclass="math inline">\(Q\)</span>）：将自动机看作有向图，其图上结点即表示状态。</li><li>起始状态（<span class="math inline">\(\text{start}\)</span>）：<spanclass="math inline">\(\text{start}\in Q\)</span>。</li><li>接受状态集合（<span class="math inline">\(F\)</span>）：<spanclass="math inline">\(F\subseteq Q\)</span>。</li><li>转移函数（<spanclass="math inline">\(\delta\)</span>）：接受两个参数返回一个值的函数，参数其一与返回值均为状态，另一参数为字符集中字符（若将自动机看作有向图，则第一参数为点，第二参数为其出边，返回值为出边指向的结点）</li></ol><p>当 DFA读入一个字符串时，会从起始状态开始按转移函数进行转移，读入结束后若指针指向接收状态，则称该自动机<span class="math inline">\(A\)</span> 接受字符串 <spanclass="math inline">\(S\)</span>，<spanclass="math inline">\(A(S)=\text{True}\)</span>；反之则称该自动机 <spanclass="math inline">\(A\)</span> 不接受字符串 <spanclass="math inline">\(S\)</span>，<spanclass="math inline">\(A(S)=\text{False}\)</span>。</p><p>空状态：如果一个状态 <span class="math inline">\(v\)</span>，对于字符<span class="math inline">\(c\)</span>，不存在转移，则令 <spanclass="math inline">\(\delta(v,c)=\text{null}\)</span>，即一个空状态，空状态表示不接受，且无法继续转移至任何一个接收状态。</p><p>若令转移函数 <span class="math inline">\(\delta\)</span>可以接受字符串，则 <spanclass="math inline">\(\delta(v,s)=\delta(\delta(v,s[1]),s[2...|s|])\)</span>。</p><p>$ $ A(s)=[(start,s)F] $ $</p><h2 id="三常见自动机">三，常见自动机</h2><h3 id="字典树"><ahref="https://oi-wiki.org/string/trie/">字典树</a></h3><h3 id="kmp-自动机"><a href="https://oi-wiki.org/string/kmp/">KMP自动机</a></h3><h3 id="ac-自动机"><ahref="https://intconstlee.github.io/posts/aho-corasick-automaton/">AC自动机</a></h3><h3 id="后缀自动机"><ahref="https://oi-wiki.org/string/sam/">后缀自动机</a></h3><h3 id="广义后缀自动机"><ahref="https://oi-wiki.org/string/general-sam/">广义后缀自动机</a></h3><h3 id="回文自动机"><ahref="https://oi-wiki.org/string/pam/">回文自动机</a></h3><h3 id="序列自动机"><ahref="https://oi-wiki.org/string/seq-automaton/">序列自动机</a></h3>]]></content>
      
      
      <categories>
          
          <category> OI 知识 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 自动机 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
